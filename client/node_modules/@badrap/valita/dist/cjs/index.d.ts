/**
 * @module
 * A typesafe validation & parsing library for TypeScript.
 *
 * @example
 * ```ts
 * import * as v from "@badrap/valita";
 *
 * const vehicle = v.union(
 *   v.object({ type: v.literal("plane"), airline: v.string() }),
 *   v.object({ type: v.literal("train") }),
 *   v.object({ type: v.literal("automobile"), make: v.string() })
 * );
 * vehicle.parse({ type: "bike" });
 * // ValitaError: invalid_literal at .type (expected "plane", "train" or "automobile")
 * ```
 */
type PrettyIntersection<V> = Extract<{
    [K in keyof V]: V[K];
}, unknown>;
type Literal = string | number | bigint | boolean;
type Key = string | number;
type InputType = "object" | "array" | "null" | "undefined" | "string" | "number" | "bigint" | "boolean";
type CustomError = undefined | string | {
    message?: string;
    path?: Key[];
};
type IssueLeaf = Readonly<{
    ok: false;
    code: "custom_error";
    error: CustomError;
} | {
    ok: false;
    code: "invalid_type";
    expected: InputType[];
} | {
    ok: false;
    code: "missing_value";
} | {
    ok: false;
    code: "invalid_literal";
    expected: Literal[];
} | {
    ok: false;
    code: "unrecognized_keys";
    keys: Key[];
} | {
    ok: false;
    code: "invalid_union";
    tree: IssueTree;
} | {
    ok: false;
    code: "invalid_length";
    minLength: number;
    maxLength: number | undefined;
}>;
type IssueTree = Readonly<{
    ok: false;
    code: "prepend";
    key: Key;
    tree: IssueTree;
}> | Readonly<{
    ok: false;
    code: "join";
    left: IssueTree;
    right: IssueTree;
}> | IssueLeaf;
type Issue = Readonly<{
    code: "custom_error";
    path: Key[];
    message?: string | undefined;
    /** @deprecated Instead of `.error` use `.message`. */
    error: CustomError;
} | {
    code: "invalid_type";
    path: Key[];
    expected: InputType[];
} | {
    code: "missing_value";
    path: Key[];
} | {
    code: "invalid_literal";
    path: Key[];
    expected: Literal[];
} | {
    code: "unrecognized_keys";
    path: Key[];
    keys: Key[];
} | {
    code: "invalid_union";
    path: Key[];
    issues: Issue[];
    /** @deprecated Instead of `.tree` use `.issues`. */
    tree: IssueTree;
} | {
    code: "invalid_length";
    path: Key[];
    minLength: number;
    maxLength: number | undefined;
}>;
/**
 * An error type representing one or more validation/parsing errors.
 *
 * The `.message` property gives a short overview of the encountered issues,
 * while the `.issue` property can be used to get a more detailed list.
 *
 * @example
 * ```ts
 * const t = v.object({ a: v.null(), b: v.null() });
 *
 * try {
 *   t.parse({ a: 1 });
 * } catch (err) {
 *   err.message;
 *   // "invalid_type at .a (expected null) (+ 1 other issue)"
 *
 *   err.issues;
 *   // [
 *   //   { code: 'invalid_type', path: [ 'a' ], expected: [ 'null' ] },
 *   //   { code: 'missing_value', path: [ 'b' ] }
 *   // ]
 * }
 * ```
 */
export declare class ValitaError extends Error {
    /** @internal */
    private readonly _issueTree;
    constructor(issueTree: IssueTree);
    get issues(): readonly Issue[];
}
/**
 * A successful validation/parsing result.
 *
 * Used in situations where both the parsing success and failure
 * cases are returned as values.
 */
export type Ok<T> = {
    readonly ok: true;
    /**
     * The successfully parsed value.
     */
    readonly value: T;
};
/**
 * A validation/parsing failure.
 *
 * Used in situations where both the parsing success and failure
 * cases are returned as values.
 */
export type Err = {
    readonly ok: false;
    /**
     * A condensed overview of the parsing issues.
     */
    readonly message: string;
    /**
     * A detailed list of the parsing issues.
     */
    readonly issues: readonly Issue[];
    /**
     * Throw a new ValitaError representing the parsing issues.
     */
    throw(): never;
};
/**
 * A validation/parsing success or failure.
 *
 * Used by parsing-related methods where and both success and failure
 * cases are returned as values (instead of raising an exception on failure).
 * The most notable example is the `Type.try(...)` method.
 *
 * The `.ok` property can to assert whether the value represents a success or
 * failure and access further information in a typesafe way.
 *
 * @example
 * ```ts
 * const t = v.string();
 *
 * // Make parsing fail or succeed about equally.
 * const result = t.try(Math.random() < 0.5 ? "hello" : null);
 *
 * if (result.ok) {
 *   // TypeScript allows accessing .value within this code block.
 *   console.log(`Success: ${result.value}`);
 * } else {
 *   // TypeScript allows accessing .message within this code block.
 *   console.log(`Failed: ${result.message}`);
 * }
 * ```
 */
export type ValitaResult<V> = Ok<V> | Err;
/**
 * Create a value for returning a successful parsing result from chain().
 *
 * @example
 * ```ts
 * const t = v.string().chain((s) => v.ok(s + ", world!"));
 *
 * t.parse("Hello");
 * // "Hello, world!"
 * ```
 */
export declare function ok<T extends Literal>(value: T): Ok<T>;
export declare function ok<T>(value: T): Ok<T>;
/**
 * Create a value for returning a parsing error from chain().
 *
 * An optional error message can be provided.
 *
 * @example
 * ```ts
 * const t = v.string().chain(() => v.err("bad value"));
 *
 * t.parse("hello");
 * // ValitaError: custom_error at . (bad value)
 * ```
 */
export declare function err(error?: CustomError): Err;
/**
 * Return the inferred output type of a validator.
 *
 * @example
 * ```ts
 * const t = v.union(v.literal(1), v.string());
 *
 * type T = v.Infer<typeof t>;
 * // type T = 1 | string;
 * ```
 */
export type Infer<T extends AbstractType> = T extends AbstractType<infer I> ? I : never;
export type ParseOptions = {
    mode?: "passthrough" | "strict" | "strip";
};
type MatcherResult = undefined | Ok<unknown> | IssueTree;
type Matcher<Input = unknown> = (value: Input, flags: number) => MatcherResult;
type TaggedMatcher = {
    tag: number;
    match: Matcher;
};
declare const MATCHER_SYMBOL: unique symbol;
declare abstract class AbstractType<Output = unknown> {
    abstract readonly name: string;
    /** @internal */
    abstract _toTerminals(func: (t: TerminalType) => void): void;
    /** @internal */
    abstract readonly [MATCHER_SYMBOL]: TaggedMatcher;
    /**
     * Return new optional type that can not be used as a standalone
     * validator. Rather, it's meant to be used as a with object validators,
     * to mark one of the object's properties as _optional_. Optional property
     * types accept both the original type, `undefined` and missing properties.
     *
     * The optional `defaultFn` function, if provided, will be called each
     * time a value that is missing or `undefined` is parsed.
     *
     * @param [defaultFn] - An optional function returning the default value.
     */
    abstract optional<T extends Literal>(defaultFn: <X extends T>() => X): Type<Exclude<Output, undefined> | T>;
    abstract optional(defaultFn: () => Exclude<Output, undefined>): Type<Exclude<Output, undefined>>;
    abstract optional<T>(defaultFn: () => T): Type<Exclude<Output, undefined> | T>;
    abstract optional(): Optional<Output>;
    /**
     * @deprecated Instead of `.default(x)` use `.optional(() => x)`.
     */
    default<T extends Literal>(defaultValue: T): Type<Exclude<Output, undefined> | T>;
    default<T>(defaultValue: T): Type<Exclude<Output, undefined> | T>;
    /**
     * Derive a new validator that uses the provided predicate function to
     * perform custom validation for the source validator's output values.
     *
     * The predicate function should return `true` when the source
     * type's output value is valid, `false` otherwise. The checked value
     * itself won't get modified or replaced, and is returned as-is on
     * validation success.
     *
     * @example A validator that accepts only numeric strings.
     * ```ts
     * const numericString = v.string().assert((s) => /^\d+$/.test(s))
     * numericString.parse("1");
     * // "1"
     * numericString.parse("foo");
     * // ValitaError: custom_error at . (validation failed)
     * ```
     *
     * You can also _refine_ the output type by passing in a
     * [type predicate](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates).
     * Note that the type predicate must have a compatible input type.
     *
     * @example A validator with its output type refined to `Date`.
     * ```ts
     * const dateType = v.unknown().assert((v): v is Date => v instanceof Date);
     * ```
     *
     * You can also pass in a custom failure messages.
     *
     * @example A validator that rejects non-integers with a custom error.
     * ```ts
     * const integer = v.number().assert((n) => Number.isInteger(n), "not an integer");
     * integer.parse(1);
     * // 1
     * integer.parse(1.5);
     * // ValitaError: custom_error at . (not an integer)
     * ```
     *
     * @param func - The assertion predicate function.
     * @param [error] - A custom error for situations when the assertion
     *                  predicate returns `false`.
     */
    assert<T extends Output>(func: ((v: Output, options: ParseOptions) => v is T) | ((v: Output, options: ParseOptions) => boolean), error?: CustomError): Type<T>;
    /**
     * Derive a new validator that uses the provided mapping function to
     * perform custom mapping for the source validator's output values.
     *
     * The mapped value's type doesn't have to stay same, but mapping must
     * always succeed (i.e. not throw) for all values that the source validator
     * outputs.
     *
     * @example
     * ```ts
     * const stringLength = v.string().assert((s) => s.length);
     * stringLength.parse("Hello, World!");
     * // 13
     * stringLength.parse(1);
     * // ValitaError: invalid_type at . (expected string)
     * ```
     *
     * @param func - The mapping function.
     */
    map<T extends Literal>(func: (v: Output, options: ParseOptions) => T): Type<T>;
    map<T>(func: (v: Output, options: ParseOptions) => T): Type<T>;
    /**
     * Derive a new validator that uses the provided mapping function to
     * perform custom parsing for the source validator's output values.
     *
     * Unlike `.map`, `.chain` can also be used for cases where the
     * transformation might fail. If the transformation fails, return an error
     * with an optional message with `err(...)`. If not, then return the
     * transformed value with `ok(...)`.
     *
     * @example A parser for date strings, returns `Date` objects on success.
     * ```ts
     * const DateType = v.string().chain((s) => {
     *   const date = new Date(s);
     *   if (isNaN(+date)) {
     *     return v.err("invalid date");
     *   }
     *   return v.ok(date);
     * });
     *
     * Date.parse("2022-01-01");
     * // 2022-01-01T00:00:00.000Z
     * Date.parse("foo");
     * // ValitaError: custom_error at . (invalid date)
     * ```
     *
     * @param func - The parsing function.
     */
    chain<T extends Literal>(func: (v: Output, options: ParseOptions) => ValitaResult<T>): Type<T>;
    chain<T>(func: (v: Output, options: ParseOptions) => ValitaResult<T>): Type<T>;
    chain<T>(type: Type<T>): Type<T>;
}
type TypeName = "unknown" | "never" | "string" | "number" | "bigint" | "boolean" | "null" | "undefined" | "literal" | "object" | "array" | "union" | "lazy" | "transform";
/**
 * A base class for all concrete validators/parsers.
 */
declare abstract class Type<Output = unknown> extends AbstractType<Output> {
    abstract name: TypeName;
    optional<T extends Literal>(defaultFn: <X extends T>() => X): Type<Exclude<Output, undefined> | T>;
    optional(defaultFn: () => Exclude<Output, undefined>): Type<Exclude<Output, undefined>>;
    optional<T>(defaultFn: () => T): Type<Exclude<Output, undefined> | T>;
    optional(): Optional<Output>;
    /**
     * Return new validator that accepts both the original type and `null`.
     *
     * The optional `defaultFn` function, if provided, will be called each
     * time a `null` is parsed.
     *
     * @param [defaultFn] - An optional function returning the default value.
     */
    nullable<T extends Literal>(defaultFn: <X extends T>() => X): Type<Exclude<Output, null> | T>;
    nullable(defaultFn: () => Exclude<Output, null>): Type<Exclude<Output, null>>;
    nullable<T>(defaultFn: () => T): Type<Exclude<Output, null> | T>;
    nullable(): UnionType<[Type<null>, this]>;
    _toTerminals(func: (t: TerminalType) => void): void;
    /**
     * Parse a value without throwing.
     */
    try(v: unknown, options?: ParseOptions): ValitaResult<Infer<this>>;
    /**
     * Parse a value. Throw a ValitaError on failure.
     */
    parse(v: unknown, options?: ParseOptions): Infer<this>;
}
/**
 * A validator/parser marked as "optional", signifying that their value can
 * be missing from the parsed object.
 *
 * As such optionals can only be used as property validators within
 * object validators.
 */
declare class Optional<Output = unknown> extends AbstractType<Output | undefined> {
    readonly name = "optional";
    readonly type: Type<Output>;
    constructor(type: Type<Output>);
    optional<T extends Literal>(defaultFn: <X extends T>() => X): Type<Exclude<Output, undefined> | T>;
    optional(defaultFn: () => Exclude<Output, undefined>): Type<Exclude<Output, undefined>>;
    optional<T>(defaultFn: () => T): Type<Exclude<Output, undefined> | T>;
    optional(): Optional<Output>;
    get [MATCHER_SYMBOL](): TaggedMatcher;
    _toTerminals(func: (t: TerminalType) => void): void;
}
type ObjectShape = Record<string, AbstractType>;
type ObjectOutput<T extends ObjectShape, R extends AbstractType | undefined> = PrettyIntersection<{
    [K in keyof T]?: T[K] extends Optional ? Infer<T[K]> : unknown;
} & {
    [K in keyof T as T[K] extends Optional ? never : K]: Infer<T[K]>;
} & (R extends Type<infer I> ? Record<string, I> : R extends Optional<infer J> ? Partial<Record<string, J>> : unknown)>;
declare class ObjectType<Shape extends ObjectShape = ObjectShape, Rest extends AbstractType | undefined = AbstractType | undefined> extends Type<ObjectOutput<Shape, Rest>> {
    readonly name = "object";
    readonly shape: Shape;
    /** @internal */
    private readonly _restType;
    /** @internal */
    private readonly _checks?;
    constructor(shape: Shape, restType: Rest, checks?: {
        func: (v: unknown) => boolean;
        issue: IssueLeaf;
    }[]);
    get [MATCHER_SYMBOL](): TaggedMatcher;
    check(func: (v: ObjectOutput<Shape, Rest>) => boolean, error?: CustomError): ObjectType<Shape, Rest>;
    rest<R extends Type>(restType: R): ObjectType<Shape, R>;
    extend<S extends ObjectShape>(shape: S): ObjectType<Omit<Shape, keyof S> & S, Rest>;
    pick<K extends (string & keyof Shape)[]>(...keys: K): ObjectType<Pick<Shape, K[number]>, undefined>;
    omit<K extends (string & keyof Shape)[]>(...keys: K): ObjectType<Omit<Shape, K[number]>, Rest>;
    partial(): ObjectType<{
        [K in keyof Shape]: Optional<Infer<Shape[K]>>;
    }, Rest extends AbstractType<infer I> ? Optional<I> : undefined>;
}
type TupleOutput<T extends Type[]> = {
    [K in keyof T]: T[K] extends Type<infer U> ? U : never;
};
type ArrayOutput<Head extends Type[], Rest extends Type | undefined, Tail extends Type[]> = [
    ...TupleOutput<Head>,
    ...(Rest extends Type ? Infer<Rest>[] : []),
    ...TupleOutput<Tail>
];
declare class ArrayOrTupleType<Head extends Type[] = Type[], Rest extends Type | undefined = Type | undefined, Tail extends Type[] = Type[]> extends Type<ArrayOutput<Head, Rest, Tail>> {
    readonly name = "array";
    readonly _prefix: Head;
    readonly _rest: Rest | undefined;
    readonly _suffix: Tail;
    constructor(prefix: Head, rest: Rest | undefined, suffix: Tail);
    get [MATCHER_SYMBOL](): TaggedMatcher;
    concat(type: ArrayType | TupleType | VariadicTupleType): ArrayOrTupleType;
}
/**
 * A validator for arbitrary-length array types like `T[]`.
 */
interface ArrayType<Element extends Type = Type> extends Type<Infer<Element>[]> {
    readonly name: "array";
    /** @internal */
    readonly _prefix: Type[];
    /** @internal */
    readonly _rest: Element;
    /** @internal */
    readonly _suffix: Type[];
    concat<Suffix extends Type[]>(type: TupleType<Suffix>): VariadicTupleType<[], Element, Suffix>;
}
/**
 * A validator for a fixed-length tuple type like `[]`, `[T1, T2]`
 * or `[T1, T2, ..., Tn]`.
 */
interface TupleType<Elements extends Type[] = Type[]> extends Type<TupleOutput<Elements>> {
    readonly name: "array";
    /** @internal */
    readonly _prefix: Elements;
    /** @internal */
    readonly _rest: undefined;
    /** @internal */
    readonly _suffix: Type[];
    concat<ConcatPrefix extends Type[]>(type: TupleType<ConcatPrefix>): TupleType<[...Elements, ...ConcatPrefix]>;
    concat<ConcatPrefix extends Type[], Rest extends Type | undefined, Suffix extends Type[]>(type: VariadicTupleType<ConcatPrefix, Rest, Suffix>): VariadicTupleType<[...Elements, ...ConcatPrefix], Rest, Suffix>;
    concat<Element extends Type>(type: ArrayType<Element>): VariadicTupleType<Elements, Element, []>;
}
/**
 * A validator for a variadic tuple type like `[T1, ...T[], Tn]`,
 * `[...T[], Tn-1, Tn]` or `[T1, T2, ...T[]]`.
 */
interface VariadicTupleType<Prefix extends Type[] = Type[], Rest extends Type | undefined = undefined, Suffix extends Type[] = Type[]> extends Type<ArrayOutput<Prefix, Rest, Suffix>> {
    readonly name: "array";
    /** @internal */
    readonly _prefix: Prefix;
    /** @internal */
    readonly _rest: Rest;
    /** @internal */
    readonly _suffix: Suffix;
    concat<OtherPrefix extends Type[]>(type: TupleType<OtherPrefix>): VariadicTupleType<Prefix, Rest, [...Suffix, ...OtherPrefix]>;
}
declare class UnionType<T extends Type[] = Type[]> extends Type<Infer<T[number]>> {
    readonly name = "union";
    readonly options: Readonly<T>;
    constructor(options: Readonly<T>);
    _toTerminals(func: (t: TerminalType) => void): void;
    get [MATCHER_SYMBOL](): TaggedMatcher;
}
/**
 * Create a validator that matches any value,
 * analogous to the TypeScript type `unknown`.
 */
export declare const unknown: () => Type;
/**
 * Create a validator that never matches any value,
 * analogous to the TypeScript type `never`.
 */
export declare const never: () => Type<never>;
/**
 * Create a validator that matches any string value.
 */
export declare const string: () => Type<string>;
/**
 * Create a validator that matches any number value.
 */
export declare const number: () => Type<number>;
/**
 * Create a validator that matches any bigint value.
 */
export declare const bigint: () => Type<bigint>;
/**
 * Create a validator that matches any boolean value.
 */
export declare const boolean: () => Type<boolean>;
/**
 * Create a validator that matches `null`.
 */
declare const null_: () => Type<null>;
export { null_ as null };
/**
 * Create a validator that matches `undefined`.
 */
declare const undefined_: () => Type<undefined>;
export { undefined_ as undefined };
declare class LiteralType<Out extends Literal = Literal> extends Type<Out> {
    readonly name = "literal";
    readonly [MATCHER_SYMBOL]: TaggedMatcher;
    readonly value: Out;
    constructor(value: Out);
}
/**
 * Create a validator for a specific string, number, bigint or boolean value.
 */
export declare const literal: <T extends Literal>(value: T) => Type<T>;
/**
 * Create a validator for an object type.
 */
export declare const object: <T extends Record<string, AbstractType>>(obj: T) => ObjectType<T, undefined>;
/**
 * Create a validator for a record type `Record<string, T>`,
 * where `T` is the output type of the given subvalidator.
 */
export declare const record: <T extends Type>(valueType?: T) => Type<Record<string, Infer<T>>>;
/**
 * Create a validator for an array type `T[]`,
 * where `T` is the output type of the given subvalidator.
 */
export declare const array: <T extends Type>(item?: T) => ArrayType<T>;
/**
 * Create a validator for an array type `[T1, T2, ..., Tn]`,
 * where `T1`, `T2`, ..., `Tn` are the output types of the given subvalidators.
 */
export declare const tuple: <T extends [] | [Type, ...Type[]]>(items: T) => TupleType<T>;
/**
 * Create a validator that matches any type `T1 | T2 | ... | Tn`,
 * where `T1`, `T2`, ..., `Tn` are the output types of the given subvalidators.
 *
 * This is analogous to how TypeScript's union types are constructed.
 */
export declare const union: <T extends Type[]>(...options: T) => UnionType<T>;
/**
 * Create a validator that can reference itself, directly or indirectly.
 *
 * In most cases an explicit type annotation is also needed, as TypeScript
 * cannot infer return types of recursive functions.
 *
 * @example
 * ```ts
 * import * as v from "@badrap/valita";
 *
 * type T = string | T[];
 * const type: v.Type<T> = v.lazy(() => v.union(v.string(), v.array(type)));
 * ```
 */
export declare const lazy: <T>(definer: () => Type<T>) => Type<T>;
type TerminalType = (Type & {
    name: "unknown" | "never" | "string" | "number" | "bigint" | "boolean" | "null" | "undefined";
}) | LiteralType | ObjectType | ArrayOrTupleType | Optional;
export type { Type, Optional };
export type { ObjectType, ArrayType, TupleType, VariadicTupleType, UnionType };
