"use strict";
/**
 * @module
 * A typesafe validation & parsing library for TypeScript.
 *
 * @example
 * ```ts
 * import * as v from "@badrap/valita";
 *
 * const vehicle = v.union(
 *   v.object({ type: v.literal("plane"), airline: v.string() }),
 *   v.object({ type: v.literal("train") }),
 *   v.object({ type: v.literal("automobile"), make: v.string() })
 * );
 * vehicle.parse({ type: "bike" });
 * // ValitaError: invalid_literal at .type (expected "plane", "train" or "automobile")
 * ```
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.lazy = exports.union = exports.tuple = exports.array = exports.record = exports.object = exports.literal = exports.undefined = exports.null = exports.boolean = exports.bigint = exports.number = exports.string = exports.never = exports.unknown = exports.ValitaError = void 0;
exports.ok = ok;
exports.err = err;
function expectedType(expected) {
    return {
        ok: false,
        code: "invalid_type",
        expected,
    };
}
const ISSUE_EXPECTED_NOTHING = expectedType([]);
const ISSUE_EXPECTED_STRING = expectedType(["string"]);
const ISSUE_EXPECTED_NUMBER = expectedType(["number"]);
const ISSUE_EXPECTED_BIGINT = expectedType(["bigint"]);
const ISSUE_EXPECTED_BOOLEAN = expectedType(["boolean"]);
const ISSUE_EXPECTED_UNDEFINED = expectedType(["undefined"]);
const ISSUE_EXPECTED_NULL = expectedType(["null"]);
const ISSUE_EXPECTED_OBJECT = expectedType(["object"]);
const ISSUE_EXPECTED_ARRAY = expectedType(["array"]);
const ISSUE_MISSING_VALUE = {
    ok: false,
    code: "missing_value",
};
function joinIssues(left, right) {
    return left ? { ok: false, code: "join", left, right } : right;
}
function prependPath(key, tree) {
    return { ok: false, code: "prepend", key, tree };
}
function cloneIssueWithPath(tree, path) {
    const code = tree.code;
    switch (code) {
        case "invalid_type":
            return { code, path, expected: tree.expected };
        case "invalid_literal":
            return { code, path, expected: tree.expected };
        case "missing_value":
            return { code, path };
        case "invalid_length":
            return {
                code,
                path,
                minLength: tree.minLength,
                maxLength: tree.maxLength,
            };
        case "unrecognized_keys":
            return { code, path, keys: tree.keys };
        case "invalid_union":
            return { code, path, tree: tree.tree, issues: collectIssues(tree.tree) };
        case "custom_error":
            if (typeof tree.error === "object" && tree.error.path !== undefined) {
                path.push(...tree.error.path);
            }
            return {
                code,
                path,
                message: typeof tree.error === "string" ? tree.error : tree.error?.message,
                error: tree.error,
            };
    }
}
function collectIssues(tree, path = [], issues = []) {
    for (;;) {
        if (tree.code === "join") {
            collectIssues(tree.left, path.slice(), issues);
            tree = tree.right;
        }
        else if (tree.code === "prepend") {
            path.push(tree.key);
            tree = tree.tree;
        }
        else {
            issues.push(cloneIssueWithPath(tree, path));
            return issues;
        }
    }
}
function separatedList(list, sep) {
    if (list.length === 0) {
        return "nothing";
    }
    else if (list.length === 1) {
        return list[0];
    }
    else {
        return `${list.slice(0, -1).join(", ")} ${sep} ${list[list.length - 1]}`;
    }
}
function formatLiteral(value) {
    return typeof value === "bigint" ? `${value}n` : JSON.stringify(value);
}
function countIssues(tree) {
    let count = 0;
    for (;;) {
        if (tree.code === "join") {
            count += countIssues(tree.left);
            tree = tree.right;
        }
        else if (tree.code === "prepend") {
            tree = tree.tree;
        }
        else {
            return count + 1;
        }
    }
}
function formatIssueTree(tree) {
    let path = "";
    let count = 0;
    for (;;) {
        if (tree.code === "join") {
            count += countIssues(tree.right);
            tree = tree.left;
        }
        else if (tree.code === "prepend") {
            path += `.${tree.key}`;
            tree = tree.tree;
        }
        else {
            break;
        }
    }
    let message = "validation failed";
    if (tree.code === "invalid_type") {
        message = `expected ${separatedList(tree.expected, "or")}`;
    }
    else if (tree.code === "invalid_literal") {
        message = `expected ${separatedList(tree.expected.map(formatLiteral), "or")}`;
    }
    else if (tree.code === "missing_value") {
        message = `missing value`;
    }
    else if (tree.code === "unrecognized_keys") {
        const keys = tree.keys;
        message = `unrecognized ${keys.length === 1 ? "key" : "keys"} ${separatedList(keys.map(formatLiteral), "and")}`;
    }
    else if (tree.code === "invalid_length") {
        const min = tree.minLength;
        const max = tree.maxLength;
        message = `expected an array with `;
        if (min > 0) {
            if (max === min) {
                message += `${min}`;
            }
            else if (max !== undefined) {
                message += `between ${min} and ${max}`;
            }
            else {
                message += `at least ${min}`;
            }
        }
        else {
            message += `at most ${max ?? "âˆž"}`;
        }
        message += ` item(s)`;
    }
    else if (tree.code === "custom_error") {
        const error = tree.error;
        if (typeof error === "string") {
            message = error;
        }
        else if (error !== undefined) {
            if (error.message !== undefined) {
                message = error.message;
            }
            if (error.path !== undefined) {
                path += "." + error.path.join(".");
            }
        }
    }
    let msg = `${tree.code} at .${path.slice(1)} (${message})`;
    if (count === 1) {
        msg += ` (+ 1 other issue)`;
    }
    else if (count > 1) {
        msg += ` (+ ${count} other issues)`;
    }
    return msg;
}
function lazyProperty(obj, prop, value, enumerable) {
    Object.defineProperty(obj, prop, {
        value,
        enumerable,
        writable: false,
    });
    return value;
}
/**
 * An error type representing one or more validation/parsing errors.
 *
 * The `.message` property gives a short overview of the encountered issues,
 * while the `.issue` property can be used to get a more detailed list.
 *
 * @example
 * ```ts
 * const t = v.object({ a: v.null(), b: v.null() });
 *
 * try {
 *   t.parse({ a: 1 });
 * } catch (err) {
 *   err.message;
 *   // "invalid_type at .a (expected null) (+ 1 other issue)"
 *
 *   err.issues;
 *   // [
 *   //   { code: 'invalid_type', path: [ 'a' ], expected: [ 'null' ] },
 *   //   { code: 'missing_value', path: [ 'b' ] }
 *   // ]
 * }
 * ```
 */
class ValitaError extends Error {
    constructor(issueTree) {
        super(formatIssueTree(issueTree));
        Object.setPrototypeOf(this, new.target.prototype);
        this.name = new.target.name;
        this._issueTree = issueTree;
    }
    get issues() {
        return lazyProperty(this, "issues", collectIssues(this._issueTree), true);
    }
}
exports.ValitaError = ValitaError;
class ErrImpl {
    constructor(issueTree) {
        this.ok = false;
        this._issueTree = issueTree;
    }
    get issues() {
        return lazyProperty(this, "issues", collectIssues(this._issueTree), true);
    }
    get message() {
        return lazyProperty(this, "message", formatIssueTree(this._issueTree), true);
    }
    throw() {
        throw new ValitaError(this._issueTree);
    }
}
function ok(value) {
    return { ok: true, value };
}
/**
 * Create a value for returning a parsing error from chain().
 *
 * An optional error message can be provided.
 *
 * @example
 * ```ts
 * const t = v.string().chain(() => v.err("bad value"));
 *
 * t.parse("hello");
 * // ValitaError: custom_error at . (bad value)
 * ```
 */
function err(error) {
    return new ErrImpl({ ok: false, code: "custom_error", error });
}
function isObject(v) {
    return typeof v === "object" && v !== null && !Array.isArray(v);
}
const FLAG_FORBID_EXTRA_KEYS = 1 << 0;
const FLAG_STRIP_EXTRA_KEYS = 1 << 1;
const FLAG_MISSING_VALUE = 1 << 2;
const TAG_UNKNOWN = 0;
const TAG_NEVER = 1;
const TAG_STRING = 2;
const TAG_NUMBER = 3;
const TAG_BIGINT = 4;
const TAG_BOOLEAN = 5;
const TAG_NULL = 6;
const TAG_UNDEFINED = 7;
const TAG_LITERAL = 8;
const TAG_OPTIONAL = 9;
const TAG_OBJECT = 10;
const TAG_ARRAY = 11;
const TAG_UNION = 12;
const TAG_SIMPLE_UNION = 13;
const TAG_TRANSFORM = 14;
const TAG_OTHER = 15;
const taggedMatcher = (tag, match) => {
    return { tag, match };
};
function callMatcher(matcher, value, flags) {
    switch (matcher.tag) {
        case TAG_UNKNOWN:
            return undefined;
        case TAG_NEVER:
            return ISSUE_EXPECTED_NOTHING;
        case TAG_STRING:
            return typeof value === "string" ? undefined : ISSUE_EXPECTED_STRING;
        case TAG_NUMBER:
            return typeof value === "number" ? undefined : ISSUE_EXPECTED_NUMBER;
        case TAG_BIGINT:
            return typeof value === "bigint" ? undefined : ISSUE_EXPECTED_BIGINT;
        case TAG_BOOLEAN:
            return typeof value === "boolean" ? undefined : ISSUE_EXPECTED_BOOLEAN;
        case TAG_NULL:
            return value === null ? undefined : ISSUE_EXPECTED_NULL;
        case TAG_UNDEFINED:
            return value === undefined ? undefined : ISSUE_EXPECTED_UNDEFINED;
        case TAG_LITERAL:
            return matcher.match(value, flags);
        case TAG_OPTIONAL:
            return matcher.match(value, flags);
        case TAG_OBJECT:
            return matcher.match(value, flags);
        case TAG_ARRAY:
            return matcher.match(value, flags);
        case TAG_UNION:
            return matcher.match(value, flags);
        case TAG_SIMPLE_UNION:
            return matcher.match(value, flags);
        case TAG_TRANSFORM:
            return matcher.match(value, flags);
        default:
            return matcher.match(value, flags);
    }
}
const MATCHER_SYMBOL = Symbol.for("@valita/internal");
class AbstractType {
    default(defaultValue) {
        const defaultResult = ok(defaultValue);
        return new TransformType(this.optional(), (v) => {
            return v === undefined ? defaultResult : undefined;
        });
    }
    /**
     * Derive a new validator that uses the provided predicate function to
     * perform custom validation for the source validator's output values.
     *
     * The predicate function should return `true` when the source
     * type's output value is valid, `false` otherwise. The checked value
     * itself won't get modified or replaced, and is returned as-is on
     * validation success.
     *
     * @example A validator that accepts only numeric strings.
     * ```ts
     * const numericString = v.string().assert((s) => /^\d+$/.test(s))
     * numericString.parse("1");
     * // "1"
     * numericString.parse("foo");
     * // ValitaError: custom_error at . (validation failed)
     * ```
     *
     * You can also _refine_ the output type by passing in a
     * [type predicate](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates).
     * Note that the type predicate must have a compatible input type.
     *
     * @example A validator with its output type refined to `Date`.
     * ```ts
     * const dateType = v.unknown().assert((v): v is Date => v instanceof Date);
     * ```
     *
     * You can also pass in a custom failure messages.
     *
     * @example A validator that rejects non-integers with a custom error.
     * ```ts
     * const integer = v.number().assert((n) => Number.isInteger(n), "not an integer");
     * integer.parse(1);
     * // 1
     * integer.parse(1.5);
     * // ValitaError: custom_error at . (not an integer)
     * ```
     *
     * @param func - The assertion predicate function.
     * @param [error] - A custom error for situations when the assertion
     *                  predicate returns `false`.
     */
    assert(func, error) {
        const err = { ok: false, code: "custom_error", error };
        return new TransformType(this, (v, flags) => func(v, flagsToOptions(flags)) ? undefined : err);
    }
    map(func) {
        return new TransformType(this, (v, flags) => ({
            ok: true,
            value: func(v, flagsToOptions(flags)),
        }));
    }
    chain(input) {
        if (typeof input === "function") {
            return new TransformType(this, (v, flags) => {
                const r = input(v, flagsToOptions(flags));
                return r.ok
                    ? r
                    : r._issueTree;
            });
        }
        return new TransformType(this, (v, flags) => callMatcher(input[MATCHER_SYMBOL], v, flags));
    }
}
/**
 * A base class for all concrete validators/parsers.
 */
class Type extends AbstractType {
    optional(defaultFn) {
        // If this type is already Optional there's no need to wrap it inside
        // a new Optional instance.
        const optional = new Optional(this);
        if (!defaultFn) {
            return optional;
        }
        return new TransformType(optional, (v) => {
            return v === undefined ? { ok: true, value: defaultFn() } : undefined;
        });
    }
    nullable(defaultFn) {
        const nullable = new SimpleUnion([null_(), this]);
        if (!defaultFn) {
            return nullable;
        }
        return new TransformType(nullable, (v) => {
            return v === null ? { ok: true, value: defaultFn() } : undefined;
        });
    }
    _toTerminals(func) {
        func(this);
    }
    /**
     * Parse a value without throwing.
     */
    try(v, options) {
        const r = callMatcher(this[MATCHER_SYMBOL], v, options === undefined
            ? FLAG_FORBID_EXTRA_KEYS
            : options.mode === "strip"
                ? FLAG_STRIP_EXTRA_KEYS
                : options.mode === "passthrough"
                    ? 0
                    : FLAG_FORBID_EXTRA_KEYS);
        return r === undefined || r.ok
            ? { ok: true, value: (r === undefined ? v : r.value) }
            : new ErrImpl(r);
    }
    /**
     * Parse a value. Throw a ValitaError on failure.
     */
    parse(v, options) {
        const r = callMatcher(this[MATCHER_SYMBOL], v, options === undefined
            ? FLAG_FORBID_EXTRA_KEYS
            : options.mode === "strip"
                ? FLAG_STRIP_EXTRA_KEYS
                : options.mode === "passthrough"
                    ? 0
                    : FLAG_FORBID_EXTRA_KEYS);
        if (r === undefined || r.ok) {
            return (r === undefined ? v : r.value);
        }
        throw new ValitaError(r);
    }
}
class SimpleUnion extends Type {
    constructor(options) {
        super();
        this.name = "union";
        this.options = options;
    }
    get [MATCHER_SYMBOL]() {
        const options = this.options.map((o) => o[MATCHER_SYMBOL]);
        return lazyProperty(this, MATCHER_SYMBOL, taggedMatcher(TAG_SIMPLE_UNION, (v, flags) => {
            let issue = ISSUE_EXPECTED_NOTHING;
            for (const option of options) {
                const result = callMatcher(option, v, flags);
                if (result === undefined || result.ok) {
                    return result;
                }
                issue = result;
            }
            return issue;
        }), false);
    }
    _toTerminals(func) {
        for (const option of this.options) {
            option._toTerminals(func);
        }
    }
}
/**
 * A validator/parser marked as "optional", signifying that their value can
 * be missing from the parsed object.
 *
 * As such optionals can only be used as property validators within
 * object validators.
 */
class Optional extends AbstractType {
    constructor(type) {
        super();
        this.name = "optional";
        this.type = type;
    }
    optional(defaultFn) {
        if (!defaultFn) {
            return this;
        }
        return new TransformType(this, (v) => {
            return v === undefined ? { ok: true, value: defaultFn() } : undefined;
        });
    }
    get [MATCHER_SYMBOL]() {
        const matcher = this.type[MATCHER_SYMBOL];
        return lazyProperty(this, MATCHER_SYMBOL, taggedMatcher(TAG_OPTIONAL, (v, flags) => v === undefined || flags & FLAG_MISSING_VALUE
            ? undefined
            : callMatcher(matcher, v, flags)), false);
    }
    _toTerminals(func) {
        func(this);
        func(undefined_());
        this.type._toTerminals(func);
    }
}
// Set a bit in position `index` to one and return the updated bitset.
// This function may or may not mutate `bits` in-place.
function setBit(bits, index) {
    if (typeof bits !== "number") {
        const idx = index >> 5;
        for (let i = bits.length; i <= idx; i++) {
            bits.push(0);
        }
        bits[idx] |= 1 << index % 32;
        return bits;
    }
    else if (index < 32) {
        return bits | (1 << index);
    }
    else {
        return setBit([bits, 0], index);
    }
}
// Get the bit at position `index`.
function getBit(bits, index) {
    if (typeof bits === "number") {
        return index < 32 ? (bits >>> index) & 1 : 0;
    }
    else {
        return (bits[index >> 5] >>> index % 32) & 1;
    }
}
class ObjectType extends Type {
    constructor(shape, restType, checks) {
        super();
        this.name = "object";
        this.shape = shape;
        this._restType = restType;
        this._checks = checks;
    }
    get [MATCHER_SYMBOL]() {
        const func = createObjectMatcher(this.shape, this._restType, this._checks);
        return lazyProperty(this, MATCHER_SYMBOL, taggedMatcher(TAG_OBJECT, (v, flags) => isObject(v) ? func(v, flags) : ISSUE_EXPECTED_OBJECT), false);
    }
    check(func, error) {
        const issue = { ok: false, code: "custom_error", error };
        return new ObjectType(this.shape, this._restType, [
            ...(this._checks ?? []),
            {
                func: func,
                issue,
            },
        ]);
    }
    rest(restType) {
        return new ObjectType(this.shape, restType);
    }
    extend(shape) {
        return new ObjectType({ ...this.shape, ...shape }, this._restType);
    }
    pick(...keys) {
        const shape = {};
        for (const key of keys) {
            set(shape, key, this.shape[key]);
        }
        return new ObjectType(shape, undefined);
    }
    omit(...keys) {
        const shape = { ...this.shape };
        for (const key of keys) {
            delete shape[key];
        }
        return new ObjectType(shape, this._restType);
    }
    partial() {
        const shape = {};
        for (const key of Object.keys(this.shape)) {
            set(shape, key, this.shape[key].optional());
        }
        const rest = this._restType?.optional();
        return new ObjectType(shape, rest);
    }
}
function set(obj, key, value) {
    if (key === "__proto__") {
        Object.defineProperty(obj, key, {
            value,
            writable: true,
            enumerable: true,
            configurable: true,
        });
    }
    else {
        obj[key] = value;
    }
}
function createObjectMatcher(shape, rest, checks) {
    const indexedEntries = Object.keys(shape).map((key, index) => {
        const type = shape[key];
        let optional = false;
        type._toTerminals((t) => {
            optional ||= t.name === "optional";
        });
        return {
            key,
            index,
            matcher: type[MATCHER_SYMBOL],
            optional,
            missing: prependPath(key, ISSUE_MISSING_VALUE),
        };
    });
    const keyedEntries = Object.create(null);
    for (const entry of indexedEntries) {
        keyedEntries[entry.key] = entry;
    }
    const restMatcher = rest?.[MATCHER_SYMBOL];
    // A fast path for record(unknown()) without checks
    const fastPath = indexedEntries.length === 0 &&
        rest?.name === "unknown" &&
        checks === undefined;
    return (obj, flags) => {
        if (fastPath) {
            return undefined;
        }
        let output = undefined;
        let issues = undefined;
        let unrecognized = undefined;
        let seenBits = 0;
        let seenCount = 0;
        if (flags & (FLAG_FORBID_EXTRA_KEYS | FLAG_STRIP_EXTRA_KEYS) ||
            restMatcher !== undefined) {
            for (const key in obj) {
                const value = obj[key];
                const entry = keyedEntries[key];
                if (entry === undefined && restMatcher === undefined) {
                    if (flags & FLAG_FORBID_EXTRA_KEYS) {
                        if (unrecognized === undefined) {
                            unrecognized = [key];
                            issues = joinIssues(issues, {
                                ok: false,
                                code: "unrecognized_keys",
                                keys: unrecognized,
                            });
                        }
                        else {
                            unrecognized.push(key);
                        }
                    }
                    else if (flags & FLAG_STRIP_EXTRA_KEYS &&
                        issues === undefined &&
                        output === undefined) {
                        output = {};
                        for (let m = 0; m < indexedEntries.length; m++) {
                            if (getBit(seenBits, m)) {
                                const k = indexedEntries[m].key;
                                set(output, k, obj[k]);
                            }
                        }
                    }
                    continue;
                }
                const r = entry === undefined
                    ? callMatcher(restMatcher, value, flags)
                    : callMatcher(entry.matcher, value, flags);
                if (r === undefined) {
                    if (output !== undefined && issues === undefined) {
                        set(output, key, value);
                    }
                }
                else if (!r.ok) {
                    issues = joinIssues(issues, prependPath(key, r));
                }
                else if (issues === undefined) {
                    if (output === undefined) {
                        output = {};
                        if (restMatcher === undefined) {
                            for (let m = 0; m < indexedEntries.length; m++) {
                                if (getBit(seenBits, m)) {
                                    const k = indexedEntries[m].key;
                                    set(output, k, obj[k]);
                                }
                            }
                        }
                        else {
                            for (const k in obj) {
                                set(output, k, obj[k]);
                            }
                        }
                    }
                    set(output, key, r.value);
                }
                if (entry !== undefined) {
                    seenCount++;
                    seenBits = setBit(seenBits, entry.index);
                }
            }
        }
        if (seenCount < indexedEntries.length) {
            for (let i = 0; i < indexedEntries.length; i++) {
                if (getBit(seenBits, i)) {
                    continue;
                }
                const entry = indexedEntries[i];
                const value = obj[entry.key];
                let extraFlags = 0;
                if (value === undefined && !(entry.key in obj)) {
                    if (!entry.optional) {
                        issues = joinIssues(issues, entry.missing);
                        continue;
                    }
                    extraFlags = FLAG_MISSING_VALUE;
                }
                const r = callMatcher(entry.matcher, value, flags | extraFlags);
                if (r === undefined) {
                    if (output !== undefined && issues === undefined && !extraFlags) {
                        set(output, entry.key, value);
                    }
                }
                else if (!r.ok) {
                    issues = joinIssues(issues, prependPath(entry.key, r));
                }
                else if (issues === undefined) {
                    if (output === undefined) {
                        output = {};
                        if (restMatcher === undefined) {
                            for (let m = 0; m < indexedEntries.length; m++) {
                                if (m < i || getBit(seenBits, m)) {
                                    const k = indexedEntries[m].key;
                                    set(output, k, obj[k]);
                                }
                            }
                        }
                        else {
                            for (const k in obj) {
                                set(output, k, obj[k]);
                            }
                            for (let m = 0; m < i; m++) {
                                if (!getBit(seenBits, m)) {
                                    const k = indexedEntries[m].key;
                                    set(output, k, obj[k]);
                                }
                            }
                        }
                    }
                    set(output, entry.key, r.value);
                }
            }
        }
        if (issues !== undefined) {
            return issues;
        }
        if (checks !== undefined) {
            for (const { func, issue } of checks) {
                if (!func(output ?? obj)) {
                    return issue;
                }
            }
        }
        return output && { ok: true, value: output };
    };
}
class ArrayOrTupleType extends Type {
    constructor(prefix, rest, suffix) {
        super();
        this.name = "array";
        this._prefix = prefix;
        this._rest = rest;
        this._suffix = suffix;
    }
    get [MATCHER_SYMBOL]() {
        const prefix = this._prefix.map((t) => t[MATCHER_SYMBOL]);
        const suffix = this._suffix.map((t) => t[MATCHER_SYMBOL]);
        const rest = this._rest?.[MATCHER_SYMBOL] ??
            taggedMatcher(1, () => ISSUE_MISSING_VALUE);
        const minLength = prefix.length + suffix.length;
        const maxLength = this._rest ? Infinity : minLength;
        const invalidLength = {
            ok: false,
            code: "invalid_length",
            minLength,
            maxLength: maxLength === Infinity ? undefined : maxLength,
        };
        return lazyProperty(this, MATCHER_SYMBOL, taggedMatcher(TAG_ARRAY, (arr, flags) => {
            if (!Array.isArray(arr)) {
                return ISSUE_EXPECTED_ARRAY;
            }
            const length = arr.length;
            if (length < minLength || length > maxLength) {
                return invalidLength;
            }
            const headEnd = prefix.length;
            const tailStart = arr.length - suffix.length;
            let issueTree = undefined;
            let output = arr;
            for (let i = 0; i < arr.length; i++) {
                const entry = i < headEnd
                    ? prefix[i]
                    : i >= tailStart
                        ? suffix[i - tailStart]
                        : rest;
                const r = callMatcher(entry, arr[i], flags);
                if (r !== undefined) {
                    if (r.ok) {
                        if (output === arr) {
                            output = arr.slice();
                        }
                        output[i] = r.value;
                    }
                    else {
                        issueTree = joinIssues(issueTree, prependPath(i, r));
                    }
                }
            }
            if (issueTree) {
                return issueTree;
            }
            else if (arr === output) {
                return undefined;
            }
            else {
                return { ok: true, value: output };
            }
        }), false);
    }
    concat(type) {
        if (this._rest) {
            if (type._rest) {
                throw new TypeError("can not concatenate two variadic types");
            }
            return new ArrayOrTupleType(this._prefix, this._rest, [
                ...this._suffix,
                ...type._prefix,
                ...type._suffix,
            ]);
        }
        else if (type._rest) {
            return new ArrayOrTupleType([...this._prefix, ...this._suffix, ...type._prefix], type._rest, type._suffix);
        }
        else {
            return new ArrayOrTupleType([...this._prefix, ...this._suffix, ...type._prefix, ...type._suffix], type._rest, type._suffix);
        }
    }
}
function toInputType(v) {
    const type = typeof v;
    if (type !== "object") {
        return type;
    }
    else if (v === null) {
        return "null";
    }
    else if (Array.isArray(v)) {
        return "array";
    }
    else {
        return type;
    }
}
function dedup(arr) {
    return [...new Set(arr)];
}
function groupTerminals(terminals) {
    const order = new Map();
    const literals = new Map();
    const types = new Map();
    const unknowns = [];
    const optionals = [];
    const expectedTypes = [];
    for (const { root, terminal } of terminals) {
        order.set(root, order.get(root) ?? order.size);
        if (terminal.name === "never") {
            // skip
        }
        else if (terminal.name === "optional") {
            optionals.push(root);
        }
        else if (terminal.name === "unknown") {
            unknowns.push(root);
        }
        else if (terminal.name === "literal") {
            const roots = literals.get(terminal.value) ?? [];
            roots.push(root);
            literals.set(terminal.value, roots);
            expectedTypes.push(toInputType(terminal.value));
        }
        else {
            const roots = types.get(terminal.name) ?? [];
            roots.push(root);
            types.set(terminal.name, roots);
            expectedTypes.push(terminal.name);
        }
    }
    const byOrder = (a, b) => {
        return (order.get(a) ?? 0) - (order.get(b) ?? 0);
    };
    for (const [value, roots] of literals) {
        const options = types.get(toInputType(value));
        if (options) {
            options.push(...roots);
            literals.delete(value);
        }
        else {
            literals.set(value, dedup(roots.concat(unknowns)).sort(byOrder));
        }
    }
    for (const [type, roots] of types) {
        types.set(type, dedup(roots.concat(unknowns)).sort(byOrder));
    }
    return {
        types,
        literals,
        unknowns: dedup(unknowns).sort(byOrder),
        optionals: dedup(optionals).sort(byOrder),
        expectedTypes: dedup(expectedTypes),
    };
}
function createObjectKeyMatcher(objects, key) {
    const list = [];
    for (const { root, terminal } of objects) {
        terminal.shape[key]._toTerminals((t) => list.push({ root, terminal: t }));
    }
    const { types, literals, optionals, unknowns, expectedTypes } = groupTerminals(list);
    if (unknowns.length > 0 || optionals.length > 1) {
        return undefined;
    }
    for (const roots of literals.values()) {
        if (roots.length > 1) {
            return undefined;
        }
    }
    for (const roots of types.values()) {
        if (roots.length > 1) {
            return undefined;
        }
    }
    const missingValue = prependPath(key, ISSUE_MISSING_VALUE);
    const issue = prependPath(key, types.size === 0
        ? {
            ok: false,
            code: "invalid_literal",
            expected: [...literals.keys()],
        }
        : {
            ok: false,
            code: "invalid_type",
            expected: expectedTypes,
        });
    const byLiteral = literals.size > 0 ? new Map() : undefined;
    if (byLiteral) {
        for (const [literal, options] of literals) {
            byLiteral.set(literal, options[0][MATCHER_SYMBOL]);
        }
    }
    const byType = types.size > 0 ? {} : undefined;
    if (byType) {
        for (const [type, options] of types) {
            byType[type] = options[0][MATCHER_SYMBOL];
        }
    }
    const optional = optionals[0]?.[MATCHER_SYMBOL];
    return (obj, flags) => {
        const value = obj[key];
        if (value === undefined && !(key in obj)) {
            return optional === undefined
                ? missingValue
                : callMatcher(optional, obj, flags);
        }
        const option = byType?.[toInputType(value)] ?? byLiteral?.get(value);
        return option ? callMatcher(option, obj, flags) : issue;
    };
}
function createUnionObjectMatcher(terminals) {
    const objects = [];
    const keyCounts = new Map();
    for (const { root, terminal } of terminals) {
        if (terminal.name === "unknown") {
            return undefined;
        }
        if (terminal.name === "object") {
            for (const key in terminal.shape) {
                keyCounts.set(key, (keyCounts.get(key) ?? 0) + 1);
            }
            objects.push({ root, terminal });
        }
    }
    if (objects.length < 2) {
        return undefined;
    }
    for (const [key, count] of keyCounts) {
        if (count === objects.length) {
            const matcher = createObjectKeyMatcher(objects, key);
            if (matcher) {
                return matcher;
            }
        }
    }
    return undefined;
}
function createUnionBaseMatcher(terminals) {
    const { expectedTypes, literals, types, unknowns, optionals } = groupTerminals(terminals);
    const issue = types.size === 0 && unknowns.length === 0
        ? {
            ok: false,
            code: "invalid_literal",
            expected: [...literals.keys()],
        }
        : {
            ok: false,
            code: "invalid_type",
            expected: expectedTypes,
        };
    const byLiteral = literals.size > 0 ? new Map() : undefined;
    if (byLiteral) {
        for (const [literal, options] of literals) {
            byLiteral.set(literal, options.map((t) => t[MATCHER_SYMBOL]));
        }
    }
    const byType = types.size > 0 ? {} : undefined;
    if (byType) {
        for (const [type, options] of types) {
            byType[type] = options.map((t) => t[MATCHER_SYMBOL]);
        }
    }
    const optionalMatchers = optionals.map((t) => t[MATCHER_SYMBOL]);
    const unknownMatchers = unknowns.map((t) => t[MATCHER_SYMBOL]);
    return (value, flags) => {
        const options = flags & FLAG_MISSING_VALUE
            ? optionalMatchers
            : (byType?.[toInputType(value)] ??
                byLiteral?.get(value) ??
                unknownMatchers);
        let count = 0;
        let issueTree = issue;
        for (let i = 0; i < options.length; i++) {
            const r = callMatcher(options[i], value, flags);
            if (r === undefined || r.ok) {
                return r;
            }
            issueTree = count > 0 ? joinIssues(issueTree, r) : r;
            count++;
        }
        if (count > 1) {
            return { ok: false, code: "invalid_union", tree: issueTree };
        }
        return issueTree;
    };
}
class UnionType extends Type {
    constructor(options) {
        super();
        this.name = "union";
        this.options = options;
    }
    _toTerminals(func) {
        for (const option of this.options) {
            option._toTerminals(func);
        }
    }
    get [MATCHER_SYMBOL]() {
        const flattened = [];
        for (const option of this.options) {
            option._toTerminals((terminal) => {
                flattened.push({ root: option, terminal });
            });
        }
        const base = createUnionBaseMatcher(flattened);
        const object = createUnionObjectMatcher(flattened);
        return lazyProperty(this, MATCHER_SYMBOL, taggedMatcher(TAG_UNION, (v, f) => object !== undefined && isObject(v) ? object(v, f) : base(v, f)), false);
    }
}
const STRICT = Object.freeze({ mode: "strict" });
const STRIP = Object.freeze({ mode: "strip" });
const PASSTHROUGH = Object.freeze({ mode: "passthrough" });
function flagsToOptions(flags) {
    return flags & FLAG_FORBID_EXTRA_KEYS
        ? STRICT
        : flags & FLAG_STRIP_EXTRA_KEYS
            ? STRIP
            : PASSTHROUGH;
}
class TransformType extends Type {
    constructor(transformed, transform) {
        super();
        this.name = "transform";
        this._transformed = transformed;
        this._transform = transform;
    }
    get [MATCHER_SYMBOL]() {
        const chain = [];
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        let next = this;
        while (next instanceof TransformType) {
            chain.push(next._transform);
            next = next._transformed;
        }
        chain.reverse();
        const matcher = next[MATCHER_SYMBOL];
        const undef = ok(undefined);
        return lazyProperty(this, MATCHER_SYMBOL, taggedMatcher(TAG_TRANSFORM, (v, flags) => {
            let result = callMatcher(matcher, v, flags);
            if (result !== undefined && !result.ok) {
                return result;
            }
            let current;
            if (result !== undefined) {
                current = result.value;
            }
            else if (flags & FLAG_MISSING_VALUE) {
                current = undefined;
                result = undef;
            }
            else {
                current = v;
            }
            for (let i = 0; i < chain.length; i++) {
                const r = chain[i](current, flags);
                if (r !== undefined) {
                    if (!r.ok) {
                        return r;
                    }
                    current = r.value;
                    result = r;
                }
            }
            return result;
        }), false);
    }
    _toTerminals(func) {
        this._transformed._toTerminals(func);
    }
}
class LazyType extends Type {
    constructor(definer) {
        super();
        this.name = "lazy";
        /** @internal */
        this._recursing = false;
        this._definer = definer;
    }
    get type() {
        return lazyProperty(this, "type", this._definer(), true);
    }
    get [MATCHER_SYMBOL]() {
        const matcher = taggedMatcher(TAG_OTHER, (value, flags) => {
            const typeMatcher = this.type[MATCHER_SYMBOL];
            matcher.tag = typeMatcher.tag;
            matcher.match = typeMatcher.match;
            lazyProperty(this, MATCHER_SYMBOL, typeMatcher, false);
            return callMatcher(typeMatcher, value, flags);
        });
        return matcher;
    }
    _toTerminals(func) {
        if (!this._recursing) {
            this._recursing = true;
            try {
                this.type._toTerminals(func);
            }
            finally {
                this._recursing = false;
            }
        }
    }
}
function singleton(name, tag, match) {
    const value = taggedMatcher(tag, match);
    class SimpleType extends Type {
        constructor() {
            super();
            this.name = name;
            this[MATCHER_SYMBOL] = value;
        }
    }
    const instance = new SimpleType();
    return /*#__NO_SIDE_EFFECTS__*/ () => instance;
}
/**
 * Create a validator that matches any value,
 * analogous to the TypeScript type `unknown`.
 */
exports.unknown = singleton("unknown", TAG_UNKNOWN, () => undefined);
/**
 * Create a validator that never matches any value,
 * analogous to the TypeScript type `never`.
 */
exports.never = singleton("never", TAG_NEVER, () => ISSUE_EXPECTED_NOTHING);
/**
 * Create a validator that matches any string value.
 */
exports.string = singleton("string", TAG_STRING, (v) => (typeof v === "string" ? undefined : ISSUE_EXPECTED_STRING));
/**
 * Create a validator that matches any number value.
 */
exports.number = singleton("number", TAG_NUMBER, (v) => (typeof v === "number" ? undefined : ISSUE_EXPECTED_NUMBER));
/**
 * Create a validator that matches any bigint value.
 */
exports.bigint = singleton("bigint", TAG_BIGINT, (v) => (typeof v === "bigint" ? undefined : ISSUE_EXPECTED_BIGINT));
/**
 * Create a validator that matches any boolean value.
 */
exports.boolean = singleton("boolean", TAG_BOOLEAN, (v) => (typeof v === "boolean" ? undefined : ISSUE_EXPECTED_BOOLEAN));
/**
 * Create a validator that matches `null`.
 */
const null_ = /*#__PURE__*/ singleton("null", TAG_NULL, (v) => (v === null ? undefined : ISSUE_EXPECTED_NULL));
exports.null = null_;
/**
 * Create a validator that matches `undefined`.
 */
const undefined_ = /*#__PURE__*/ singleton("undefined", TAG_UNDEFINED, (v) => (v === undefined ? undefined : ISSUE_EXPECTED_UNDEFINED));
exports.undefined = undefined_;
class LiteralType extends Type {
    constructor(value) {
        super();
        this.name = "literal";
        const issue = {
            ok: false,
            code: "invalid_literal",
            expected: [value],
        };
        this[MATCHER_SYMBOL] = taggedMatcher(TAG_LITERAL, (v) => v === value ? undefined : issue);
        this.value = value;
    }
}
/**
 * Create a validator for a specific string, number, bigint or boolean value.
 */
const literal = (value) => {
    return /*#__PURE__*/ new LiteralType(value);
};
exports.literal = literal;
/**
 * Create a validator for an object type.
 */
const object = (obj) => {
    return /*#__PURE__*/ new ObjectType(obj, undefined);
};
exports.object = object;
/**
 * Create a validator for a record type `Record<string, T>`,
 * where `T` is the output type of the given subvalidator.
 */
const record = (valueType) => {
    return /*#__PURE__*/ new ObjectType({}, valueType ?? (0, exports.unknown)());
};
exports.record = record;
/**
 * Create a validator for an array type `T[]`,
 * where `T` is the output type of the given subvalidator.
 */
const array = (item) => {
    return /*#__PURE__*/ new ArrayOrTupleType([], item ?? (0, exports.unknown)(), []);
};
exports.array = array;
/**
 * Create a validator for an array type `[T1, T2, ..., Tn]`,
 * where `T1`, `T2`, ..., `Tn` are the output types of the given subvalidators.
 */
const tuple = (items) => {
    return /*#__PURE__*/ new ArrayOrTupleType(items, undefined, []);
};
exports.tuple = tuple;
/**
 * Create a validator that matches any type `T1 | T2 | ... | Tn`,
 * where `T1`, `T2`, ..., `Tn` are the output types of the given subvalidators.
 *
 * This is analogous to how TypeScript's union types are constructed.
 */
const union = (...options) => {
    return /*#__PURE__*/ new UnionType(options);
};
exports.union = union;
/**
 * Create a validator that can reference itself, directly or indirectly.
 *
 * In most cases an explicit type annotation is also needed, as TypeScript
 * cannot infer return types of recursive functions.
 *
 * @example
 * ```ts
 * import * as v from "@badrap/valita";
 *
 * type T = string | T[];
 * const type: v.Type<T> = v.lazy(() => v.union(v.string(), v.array(type)));
 * ```
 */
const lazy = (definer) => {
    return new LazyType(definer);
};
exports.lazy = lazy;
//# sourceMappingURL=index.js.map