import { HELP_COMMAND_INDEX } from './core/constants.js';
import { CliBuilder } from './core/index.js';
import { Option } from './options/base.js';
import { Command } from './command.js';
import { HelpCommand } from './help-command.js';
const errorCommandSymbol = Symbol('errorCommand');
export class Program {
    builder;
    registrations = new Map();
    binaryLabel;
    binaryName;
    binaryVersion;
    constructor({ binaryLabel, binaryName: binaryNameOpt = `...`, binaryVersion }) {
        this.builder = new CliBuilder({ binaryName: binaryNameOpt });
        this.binaryLabel = binaryLabel;
        this.binaryName = binaryNameOpt;
        this.binaryVersion = binaryVersion;
    }
    register(commandClass) {
        const specs = new Map();
        const command = new commandClass();
        for (const key in command) {
            const value = command[key];
            if (value instanceof Option) {
                specs.set(key, value);
            }
        }
        const builder = this.builder.command();
        const index = builder.cliIndex;
        const paths = commandClass.paths;
        if (typeof paths !== `undefined`) {
            for (const path of paths) {
                builder.addPath(path);
            }
        }
        this.registrations.set(commandClass, { specs, builder, index });
        for (const [key, opt] of specs.entries()) {
            opt.define(builder, key);
        }
        builder.setContext(commandClass);
    }
    process(opts) {
        const { input, partial } = typeof opts === `object` && Array.isArray(opts) ? { input: opts } : opts;
        const { contexts, process } = this.builder.compile();
        const state = process(input, { partial });
        switch (state.selectedIndex) {
            case HELP_COMMAND_INDEX: {
                const command = HelpCommand.from(state, contexts);
                command.tokens = state.tokens;
                return command;
            }
            default: {
                const commandClass = contexts[state.selectedIndex];
                const record = this.registrations.get(commandClass);
                if (typeof record === `undefined`) {
                    throw new Error(`Assertion failed: Expected the command class to have been registered.`);
                }
                const command = new commandClass();
                command.tokens = state.tokens;
                command.path = state.path;
                try {
                    for (const [key, opt] of record.specs.entries()) {
                        command[key] = opt.transform(record.builder, key, state);
                    }
                    return command;
                }
                catch (error) {
                    error[errorCommandSymbol] = command;
                    throw error;
                }
            }
        }
    }
    async run(input) {
        let command;
        if (!Array.isArray(input)) {
            command = input;
        }
        else {
            try {
                command = this.process(input);
            }
            catch (error) {
                console.log(this.error(error));
                return 1;
            }
        }
        if (command.help) {
            console.log(this.usage(command, { detailed: true }));
            return 0;
        }
        command.program = {
            binaryLabel: this.binaryLabel,
            binaryName: this.binaryName,
            binaryVersion: this.binaryVersion,
            definitions: () => this.definitions(),
            definition: (command) => this.definition(command),
            process: (input) => this.process(input),
            error: (error, opts) => this.error(error, opts),
            usage: (command, opts) => this.usage(command, opts),
        };
        let exitCode;
        try {
            exitCode = await command.execute().catch((error) => command.catch(error).then(() => 0));
        }
        catch (error) {
            console.log(this.error(error, { command }));
            return 1;
        }
        return exitCode;
    }
    definition(commandClass) {
        if (!commandClass.usage) {
            return null;
        }
        const { usage: path } = this.getUsageByRegistration(commandClass, { detailed: false });
        const { usage, options } = this.getUsageByRegistration(commandClass, {
            detailed: true,
            inlineOptions: false,
        });
        const category = typeof commandClass.usage.category !== `undefined`
            ? formatText(commandClass.usage.category)
            : undefined;
        const description = typeof commandClass.usage.description !== `undefined`
            ? formatText(commandClass.usage.description)
            : undefined;
        const details = typeof commandClass.usage.details !== `undefined` ? formatText(commandClass.usage.details) : undefined;
        const examples = typeof commandClass.usage.examples !== `undefined`
            ? commandClass.usage.examples.map(([label, cli]) => [
                formatText(label),
                cli.replace(/\$0/g, this.binaryName),
            ])
            : undefined;
        return { path, usage, category, description, details, examples, options };
    }
    definitions() {
        const data = [];
        for (const commandClass of this.registrations.keys()) {
            const usage = this.definition(commandClass);
            if (!usage) {
                continue;
            }
            data.push(usage);
        }
        return data;
    }
    usage(command = null, { detailed = false, prefix = `$ ` } = {}) {
        // In case the default command is the only one, we can just show the command help rather than the general one
        if (command === null) {
            for (const commandClass of this.registrations.keys()) {
                const paths = commandClass.paths;
                const isDocumented = typeof commandClass.usage !== `undefined`;
                const isExclusivelyDefault = !paths || paths.length === 0 || (paths.length === 1 && paths[0].length === 0);
                const isDefault = isExclusivelyDefault || (paths?.some((path) => path.length === 0) ?? false);
                if (isDefault) {
                    if (command) {
                        command = null;
                        break;
                    }
                    else {
                        command = commandClass;
                    }
                }
                else {
                    if (isDocumented) {
                        command = null;
                        continue;
                    }
                }
            }
            if (command) {
                detailed = true;
            }
        }
        const commandClass = command !== null && command instanceof Command
            ? command.constructor
            : command;
        let result = '';
        if (!commandClass) {
            const commandsByCategories = new Map();
            for (const [commandClass, { index }] of this.registrations.entries()) {
                if (typeof commandClass.usage === `undefined`) {
                    continue;
                }
                const category = typeof commandClass.usage.category !== `undefined` ? formatText(commandClass.usage.category) : null;
                let categoryCommands = commandsByCategories.get(category);
                if (typeof categoryCommands === `undefined`) {
                    commandsByCategories.set(category, (categoryCommands = []));
                }
                const { usage } = this.getUsageByIndex(index);
                categoryCommands.push({ commandClass, usage });
            }
            const categoryNames = Array.from(commandsByCategories.keys()).sort((a, b) => {
                if (a === null)
                    return -1;
                if (b === null)
                    return +1;
                return a.localeCompare(b, `en`, { usage: `sort`, caseFirst: `upper` });
            });
            const hasLabel = typeof this.binaryLabel !== `undefined`;
            const hasVersion = typeof this.binaryVersion !== `undefined`;
            if (hasLabel || hasVersion) {
                if (hasLabel && hasVersion) {
                    result += `${`${this.binaryLabel} - ${this.binaryVersion}`}\n\n`;
                }
                else if (hasLabel) {
                    result += `${`${this.binaryLabel}`}\n`;
                }
                else {
                    result += `${`${this.binaryVersion}`}\n`;
                }
                result += `  ${prefix}${this.binaryName} <command>\n`;
            }
            else {
                result += `${prefix}${this.binaryName} <command>\n`;
            }
            for (const categoryName of categoryNames) {
                const commands = commandsByCategories
                    .get(categoryName)
                    .slice()
                    .sort((a, b) => {
                    return a.usage.localeCompare(b.usage, `en`, { usage: `sort`, caseFirst: `upper` });
                });
                const header = categoryName !== null ? categoryName.trim() : `General commands`;
                result += `\n`;
                result += `${header}\n`;
                for (const { commandClass, usage } of commands) {
                    const doc = commandClass.usage.description || `undocumented`;
                    result += `\n`;
                    result += `  ${usage}\n`;
                    result += `    ${formatText(doc)}`;
                }
            }
            result += `\n\n`;
            result += formatText(`You can also print more details about any of these commands by calling them with the \`-h, --help\` flag right after the command name.`);
        }
        else {
            if (!detailed) {
                const { usage } = this.getUsageByRegistration(commandClass);
                result += `${prefix}${usage}\n`;
            }
            else {
                const { description = '', details = '', examples = [] } = commandClass.usage || {};
                if (description !== '') {
                    result += formatText(description).replace(/^./, ($0) => $0.toUpperCase());
                    result += `\n`;
                }
                if (details !== '' || examples.length > 0) {
                    result += `${`Usage`}\n`;
                    result += `\n`;
                }
                const { usage, options } = this.getUsageByRegistration(commandClass, { inlineOptions: false });
                result += `${prefix}${usage}\n`;
                if (options.length > 0) {
                    result += `\n`;
                    result += `Options\n`;
                    const maxDefinitionLength = options.reduce((length, option) => {
                        return Math.max(length, option.definition.length);
                    }, 0);
                    result += `\n`;
                    for (const { definition, description } of options) {
                        result += `  ${definition.padEnd(maxDefinitionLength)}    ${formatText(description)}\n`;
                    }
                }
                if (details !== '') {
                    result += `\n`;
                    result += `Details\n`;
                    result += `\n`;
                    result += formatText(details);
                }
                if (examples.length > 0) {
                    result += `\n\n`;
                    result += `Examples\n`;
                    for (const [description, example] of examples) {
                        result += `\n`;
                        result += formatText(description);
                        result += `\n${example.replace(/^/m, `  ${prefix}`).replace(/\$0/g, this.binaryName)}\n`;
                    }
                }
            }
        }
        return result;
    }
    error(error, { command = error[errorCommandSymbol] ?? null, } = {}) {
        if (!error || typeof error !== `object` || !(`stack` in error)) {
            error = new Error(`Execution failed with a non-error rejection (rejected value: ${JSON.stringify(error)})`);
        }
        let result = '';
        let name = error.name.replace(/([a-z])([A-Z])/g, `$1 $2`);
        if (name === `Error`) {
            name = `Internal Error`;
        }
        result += `${name}: ${error.message}\n`;
        const meta = error.clipanion;
        if (typeof meta !== `undefined`) {
            if (meta.type === `usage`) {
                result += `\n`;
                result += this.usage(command);
            }
        }
        else {
            if (error.stack) {
                result += `${error.stack.replace(/^.*\n/, '')}\n`;
            }
        }
        return result;
    }
    getUsageByRegistration(klass, opts) {
        const record = this.registrations.get(klass);
        if (typeof record === `undefined`) {
            throw new Error(`Assertion failed: Unregistered command`);
        }
        return this.getUsageByIndex(record.index, opts);
    }
    getUsageByIndex(n, opts) {
        return this.builder.getBuilderByIndex(n).usage(opts);
    }
}
function formatText(text) {
    return dedent(text.replace(/^[ \t]*\n|\n[ \t]*$/g, '').replace(/\t/g, '  '));
}
function dedent(text) {
    const lines = text.split(`\n`);
    const nonEmptyLines = lines.filter((line) => line.match(/\S/));
    const indent = nonEmptyLines.length > 0
        ? nonEmptyLines.reduce((minLength, line) => Math.min(minLength, line.length - line.trimStart().length), Number.MAX_VALUE)
        : 0;
    return lines.map((line) => line.slice(indent).trimRight()).join(`\n`);
}
//# sourceMappingURL=program.js.map