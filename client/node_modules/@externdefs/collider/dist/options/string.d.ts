import type * as v from '@badrap/valita';
import { type CommandBuilder, type RunState } from '../core/index.js';
import { Option, type OptionFlags, type OptionReturn, type WithArity } from './base.js';
export type StringNamedOptionNoBoolean<T, Arity extends number = 1> = OptionFlags & {
    validator?: v.Type<T>;
    tolerateBoolean?: false;
    arity?: Arity;
};
export type StringNamedOptionTolerateBoolean<T> = OptionFlags & {
    validator?: v.Type<T>;
    tolerateBoolean: boolean;
    arity?: 0;
};
export type StringNamedOptionFlags<T> = StringNamedOptionNoBoolean<T> | StringNamedOptionTolerateBoolean<T>;
export type StringPositionalOptionFlags<T> = {
    validator?: v.Type<T>;
    name?: string;
    required?: boolean;
};
export declare class StringOption<T> extends Option<T> {
    description: string | undefined;
    required: boolean;
    hidden: boolean;
    descriptor: string[];
    initialValue: WithArity<string, number> | string | boolean | undefined;
    arity: number;
    tolerateBoolean: boolean;
    validator: v.Type<T> | undefined;
    constructor(descriptor: string[], initialValue: WithArity<string, number> | string | boolean | undefined, options: StringNamedOptionFlags<T>);
    define(builder: CommandBuilder<unknown>, _key: string): void;
    transform(_builder: CommandBuilder<unknown>, key: string, state: RunState): T;
}
/**
 * Used to annotate positional options. Such options will be strings
 * unless they are provided a schema, which will then be used for coercion.
 *
 * Be careful: this function is order-dependent! Make sure to define your
 * positional options in the same order you expect to find them on the
 * command line.
 */
export declare function String(): OptionReturn<string>;
export declare function String<T = string>(opts: StringPositionalOptionFlags<T> & {
    required: false;
}): OptionReturn<T | undefined>;
export declare function String<T = string>(opts: StringPositionalOptionFlags<T>): OptionReturn<T>;
/**
 * Used to annotate string options. Such options will be typed as strings
 * unless they are provided a schema, which will then be used for coercion.
 *
 * @example
 * --foo=hello --bar world
 *     â–º {"foo": "hello", "bar": "world"}
 */
export declare function String<T extends {} = string, Arity extends number = 1>(descriptor: string[], opts: StringNamedOptionNoBoolean<T, Arity> & {
    required: true;
}): OptionReturn<WithArity<T, Arity>>;
export declare function String<T extends {} = string, Arity extends number = 1>(descriptor: string[], opts?: StringNamedOptionNoBoolean<T, Arity>): OptionReturn<WithArity<T, Arity> | undefined>;
export declare function String<T extends {} = string, Arity extends number = 1>(descriptor: string[], initialValue: WithArity<string, Arity>, opts?: Omit<StringNamedOptionNoBoolean<T, Arity>, 'required'>): OptionReturn<WithArity<T, Arity>>;
export declare function String<T = string>(descriptor: string[], opts: StringNamedOptionTolerateBoolean<T> & {
    required: true;
}): OptionReturn<T | boolean>;
export declare function String<T = string>(descriptor: string[], opts: StringNamedOptionTolerateBoolean<T>): OptionReturn<T | boolean | undefined>;
export declare function String<T = string>(descriptor: string[], initialValue: string | boolean, opts: Omit<StringNamedOptionTolerateBoolean<T>, 'required'>): OptionReturn<T | boolean>;
