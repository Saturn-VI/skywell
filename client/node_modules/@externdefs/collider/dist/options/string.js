import { UsageError } from '../core/errors.js';
import { NoLimits } from '../core/index.js';
import { Option, rerouteArguments } from './base.js';
function StringNamed(descriptor, initialValueBase, optionsBase) {
    const [initialValue, opts] = rerouteArguments(initialValueBase, optionsBase ?? {});
    return new StringOption(descriptor, initialValue, opts);
}
function applyValidator(name, validator, value) {
    const result = validator.try(value);
    if (result.ok) {
        return result.value;
    }
    const message = result.message.replace(/^custom_error at \. \((.+)\)$/, '$1').replace(' at . ', ' ');
    throw new UsageError(`Invalid usage for ${name}: ${message}`);
}
export class StringOption extends Option {
    description;
    required;
    hidden;
    descriptor;
    initialValue;
    arity;
    tolerateBoolean;
    validator;
    constructor(descriptor, initialValue, options) {
        super();
        this.description = options.description;
        this.required = options.required ?? false;
        this.hidden = options.hidden ?? false;
        this.descriptor = descriptor;
        this.initialValue = initialValue;
        this.arity = options.tolerateBoolean ? 0 : (options.arity ?? 1);
        this.tolerateBoolean = options.tolerateBoolean ?? false;
        this.validator = options.validator;
    }
    define(builder, _key) {
        builder.addOption({
            names: this.descriptor,
            arity: this.arity,
            hidden: this.hidden,
            description: this.description,
            required: this.required,
        });
    }
    transform(_builder, key, state) {
        const nameSet = new Set(this.descriptor);
        let usedName;
        let currentValue = this.initialValue;
        for (const { name, value } of state.options) {
            if (!nameSet.has(name)) {
                continue;
            }
            usedName = name;
            currentValue = value;
        }
        if (typeof currentValue === 'string' && this.validator) {
            return applyValidator(usedName ?? key, this.validator, currentValue);
        }
        else {
            return currentValue;
        }
    }
}
function StringPositional(options = {}) {
    return new StringPositionalOption(options);
}
class StringPositionalOption extends Option {
    name;
    required;
    validator;
    constructor(options) {
        super();
        this.name = options.name;
        this.required = options.required ?? true;
        this.validator = options.validator;
    }
    define(builder, key) {
        builder.addPositional({
            name: this.name ?? key,
            required: this.required,
        });
    }
    transform(_builder, key, state) {
        for (let i = 0; i < state.positionals.length; ++i) {
            // We skip NoLimits extras. We only care about
            // required and optional finite positionals.
            if (state.positionals[i].extra === NoLimits) {
                continue;
            }
            // We skip optional positionals when we only
            // care about required positionals.
            if (this.required && state.positionals[i].extra === true) {
                continue;
            }
            // We skip required positionals when we only
            // care about optional positionals.
            if (!this.required && state.positionals[i].extra === false) {
                continue;
            }
            // We remove the positional from the list
            const [positional] = state.positionals.splice(i, 1);
            if (this.validator) {
                return applyValidator(this.name ?? key, this.validator, positional.value);
            }
            else {
                return positional.value;
            }
        }
        return undefined;
    }
}
// This function is badly typed, but it doesn't matter because the overloads provide the true public typings
export function String(descriptor, ...args) {
    if (Array.isArray(descriptor)) {
        return StringNamed(descriptor, ...args);
    }
    else {
        return StringPositional(descriptor);
    }
}
//# sourceMappingURL=string.js.map