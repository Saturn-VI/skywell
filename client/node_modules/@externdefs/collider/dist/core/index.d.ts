import { NodeType } from './constants.js';
export declare function debug(str: string): void;
export type StateMachine = {
    nodes: Node[];
};
export type TokenBase = {
    segmentIndex: number;
};
export type PathToken = TokenBase & {
    type: `path`;
    slice?: undefined;
};
export type PositionalToken = TokenBase & {
    type: `positional`;
    slice?: undefined;
};
export type OptionToken = TokenBase & {
    type: `option`;
    slice?: [number, number];
    option: string;
};
export type AssignToken = TokenBase & {
    type: `assign`;
    slice: [number, number];
};
export type ValueToken = TokenBase & {
    type: `value`;
    slice?: [number, number];
};
export type Token = PathToken | PositionalToken | OptionToken | AssignToken | ValueToken;
export type RunState = {
    candidateUsage: string | null;
    requiredOptions: string[][];
    errorMessage: string | null;
    ignoreOptions: boolean;
    options: {
        name: string;
        value: any;
    }[];
    path: string[];
    positionals: {
        value: string;
        extra: boolean | typeof NoLimits;
    }[];
    remainder: string | null;
    selectedIndex: number | null;
    tokens: Token[];
};
export declare function makeStateMachine(): StateMachine;
export declare function makeAnyOfMachine(inputs: StateMachine[]): StateMachine;
export declare function injectNode(machine: StateMachine, node: Node): number;
export declare function simplifyMachine(input: StateMachine): void;
export declare function debugMachine(machine: StateMachine, { prefix }?: {
    prefix?: string;
}): void;
export declare function runMachineInternal(machine: StateMachine, input: string[], partial?: boolean): {
    node: number;
    state: RunState;
}[];
export declare function trimSmallerBranches(branches: {
    node: number;
    state: RunState;
}[]): {
    node: number;
    state: RunState;
}[];
export declare function selectBestState(input: string[], states: RunState[]): RunState;
export declare function aggregateHelpStates(states: RunState[]): RunState[];
type Transition = {
    to: number;
    reducer?: Callback<keyof typeof reducers, typeof reducers>;
};
type Node = {
    dynamics: [Callback<keyof typeof tests, typeof tests>, Transition][];
    shortcuts: Transition[];
    statics: {
        [segment: string]: Transition[];
    };
};
export declare function makeNode(): Node;
export declare function isTerminalNode(node: number): node is NodeType.SuccessNode | NodeType.ErrorNode;
export declare function cloneTransition(input: Transition, offset?: number): {
    to: number;
    reducer: "setCandidateState" | "setSelectedIndex" | "pushBatch" | "pushBound" | "pushPath" | "pushPositional" | "pushExtra" | "pushExtraNoLimits" | "pushTrue" | "pushFalse" | "pushUndefined" | "pushStringValue" | "setStringValue" | "inhibateOptions" | "useHelp" | "setError" | "setOptionArityError" | ["setCandidateState" | "setSelectedIndex" | "pushBatch" | "pushBound" | "pushPath" | "pushPositional" | "pushExtra" | "pushExtraNoLimits" | "pushTrue" | "pushFalse" | "pushUndefined" | "pushStringValue" | "setStringValue" | "inhibateOptions" | "useHelp" | "setError" | "setOptionArityError"] | ["setCandidateState" | "setSelectedIndex" | "pushBatch" | "pushBound" | "pushPath" | "pushPositional" | "pushExtra" | "pushExtraNoLimits" | "pushTrue" | "pushFalse" | "pushUndefined" | "pushStringValue" | "setStringValue" | "inhibateOptions" | "useHelp" | "setError" | "setOptionArityError", candidateState: Partial<RunState>] | ["setCandidateState" | "setSelectedIndex" | "pushBatch" | "pushBound" | "pushPath" | "pushPositional" | "pushExtra" | "pushExtraNoLimits" | "pushTrue" | "pushFalse" | "pushUndefined" | "pushStringValue" | "setStringValue" | "inhibateOptions" | "useHelp" | "setError" | "setOptionArityError", index: number] | ["setCandidateState" | "setSelectedIndex" | "pushBatch" | "pushBound" | "pushPath" | "pushPositional" | "pushExtra" | "pushExtraNoLimits" | "pushTrue" | "pushFalse" | "pushUndefined" | "pushStringValue" | "setStringValue" | "inhibateOptions" | "useHelp" | "setError" | "setOptionArityError", names: Map<string, string>] | ["setCandidateState" | "setSelectedIndex" | "pushBatch" | "pushBound" | "pushPath" | "pushPositional" | "pushExtra" | "pushExtraNoLimits" | "pushTrue" | "pushFalse" | "pushUndefined" | "pushStringValue" | "setStringValue" | "inhibateOptions" | "useHelp" | "setError" | "setOptionArityError", name: string] | ["setCandidateState" | "setSelectedIndex" | "pushBatch" | "pushBound" | "pushPath" | "pushPositional" | "pushExtra" | "pushExtraNoLimits" | "pushTrue" | "pushFalse" | "pushUndefined" | "pushStringValue" | "setStringValue" | "inhibateOptions" | "useHelp" | "setError" | "setOptionArityError", name: string] | ["setCandidateState" | "setSelectedIndex" | "pushBatch" | "pushBound" | "pushPath" | "pushPositional" | "pushExtra" | "pushExtraNoLimits" | "pushTrue" | "pushFalse" | "pushUndefined" | "pushStringValue" | "setStringValue" | "inhibateOptions" | "useHelp" | "setError" | "setOptionArityError", _name: string] | ["setCandidateState" | "setSelectedIndex" | "pushBatch" | "pushBound" | "pushPath" | "pushPositional" | "pushExtra" | "pushExtraNoLimits" | "pushTrue" | "pushFalse" | "pushUndefined" | "pushStringValue" | "setStringValue" | "inhibateOptions" | "useHelp" | "setError" | "setOptionArityError", command: number] | ["setCandidateState" | "setSelectedIndex" | "pushBatch" | "pushBound" | "pushPath" | "pushPositional" | "pushExtra" | "pushExtraNoLimits" | "pushTrue" | "pushFalse" | "pushUndefined" | "pushStringValue" | "setStringValue" | "inhibateOptions" | "useHelp" | "setError" | "setOptionArityError", errorMessage: string] | undefined;
};
export declare function cloneNode(input: Node, offset?: number): Node;
export declare function registerDynamic<T extends keyof typeof tests, R extends keyof typeof reducers>(machine: StateMachine, from: NodeType | number, test: Callback<T, typeof tests>, to: NodeType | number, reducer?: Callback<R, typeof reducers>): void;
export declare function registerShortcut<R extends keyof typeof reducers>(machine: StateMachine, from: NodeType | number, to: NodeType | number, reducer?: Callback<R, typeof reducers>): void;
export declare function registerStatic<R extends keyof typeof reducers>(machine: StateMachine, from: NodeType | number, test: string, to: NodeType | number, reducer?: Callback<R, typeof reducers>): void;
type UndefinedKeys<T> = {
    [P in keyof T]-?: undefined extends T[P] ? P : never;
}[keyof T];
type UndefinedTupleKeys<T extends unknown[]> = UndefinedKeys<Omit<T, keyof []>>;
type TupleKeys<T> = Exclude<keyof T, keyof []>;
export type CallbackFn<P extends any[], R> = (state: RunState, segment: string, segmentIndex: number, ...args: P) => R;
export type CallbackFnParameters<T extends CallbackFn<any, any>> = T extends (state: RunState, segment: string, segmentIndex: number, ...args: infer P) => any ? P : never;
export type CallbackStore<T extends string, R> = Record<T, CallbackFn<any, R>>;
export type Callback<T extends string, S extends CallbackStore<T, any>> = [
    TupleKeys<CallbackFnParameters<S[T]>>
] extends [UndefinedTupleKeys<CallbackFnParameters<S[T]>>] ? T | [T, ...CallbackFnParameters<S[T]>] : [T, ...CallbackFnParameters<S[T]>];
export declare function execute<T extends string, R, S extends CallbackStore<T, R>>(store: S, callback: Callback<T, S>, state: RunState, segment: string, segmentIndex: number): R;
export declare const tests: {
    always: () => boolean;
    isOptionLike: (state: RunState, segment: string) => boolean;
    isNotOptionLike: (state: RunState, segment: string) => boolean;
    isOption: (state: RunState, segment: string, _segmentIndex: number, name: string) => boolean;
    isBatchOption: (state: RunState, segment: string, _segmentIndex: number, names: Map<string, string>) => boolean;
    isBoundOption: (state: RunState, segment: string, _segmentIndex: number, names: Map<string, string>, options: OptDefinition[]) => boolean;
    isNegatedOption: (state: RunState, segment: string, _segmentIndex: number, name: string) => boolean;
    isHelp: (state: RunState, segment: string) => boolean;
    isUnsupportedOption: (state: RunState, segment: string, _segmentIndex: number, names: Map<string, string>) => boolean;
    isInvalidOption: (state: RunState, segment: string) => boolean;
};
export declare const reducers: {
    setCandidateState: (state: RunState, _segment: string, _segmentIndex: number, candidateState: Partial<RunState>) => {
        candidateUsage: string | null;
        requiredOptions: string[][];
        errorMessage: string | null;
        ignoreOptions: boolean;
        options: {
            name: string;
            value: any;
        }[];
        path: string[];
        positionals: {
            value: string;
            extra: boolean | typeof NoLimits;
        }[];
        remainder: string | null;
        selectedIndex: number | null;
        tokens: Token[];
    };
    setSelectedIndex: (state: RunState, _segment: string, _segmentIndex: number, index: number) => {
        selectedIndex: number;
        candidateUsage: string | null;
        requiredOptions: string[][];
        errorMessage: string | null;
        ignoreOptions: boolean;
        options: {
            name: string;
            value: any;
        }[];
        path: string[];
        positionals: {
            value: string;
            extra: boolean | typeof NoLimits;
        }[];
        remainder: string | null;
        tokens: Token[];
    };
    pushBatch: (state: RunState, segment: string, segmentIndex: number, names: Map<string, string>) => {
        options: {
            name: string;
            value: any;
        }[];
        tokens: Token[];
        candidateUsage: string | null;
        requiredOptions: string[][];
        errorMessage: string | null;
        ignoreOptions: boolean;
        path: string[];
        positionals: {
            value: string;
            extra: boolean | typeof NoLimits;
        }[];
        remainder: string | null;
        selectedIndex: number | null;
    };
    pushBound: (state: RunState, segment: string, segmentIndex: number) => {
        options: {
            name: string;
            value: any;
        }[];
        tokens: Token[];
        candidateUsage: string | null;
        requiredOptions: string[][];
        errorMessage: string | null;
        ignoreOptions: boolean;
        path: string[];
        positionals: {
            value: string;
            extra: boolean | typeof NoLimits;
        }[];
        remainder: string | null;
        selectedIndex: number | null;
    };
    pushPath: (state: RunState, segment: string, segmentIndex: number) => {
        path: string[];
        tokens: Token[];
        candidateUsage: string | null;
        requiredOptions: string[][];
        errorMessage: string | null;
        ignoreOptions: boolean;
        options: {
            name: string;
            value: any;
        }[];
        positionals: {
            value: string;
            extra: boolean | typeof NoLimits;
        }[];
        remainder: string | null;
        selectedIndex: number | null;
    };
    pushPositional: (state: RunState, segment: string, segmentIndex: number) => {
        positionals: {
            value: string;
            extra: boolean | typeof NoLimits;
        }[];
        tokens: Token[];
        candidateUsage: string | null;
        requiredOptions: string[][];
        errorMessage: string | null;
        ignoreOptions: boolean;
        options: {
            name: string;
            value: any;
        }[];
        path: string[];
        remainder: string | null;
        selectedIndex: number | null;
    };
    pushExtra: (state: RunState, segment: string, segmentIndex: number) => {
        positionals: {
            value: string;
            extra: boolean | typeof NoLimits;
        }[];
        tokens: Token[];
        candidateUsage: string | null;
        requiredOptions: string[][];
        errorMessage: string | null;
        ignoreOptions: boolean;
        options: {
            name: string;
            value: any;
        }[];
        path: string[];
        remainder: string | null;
        selectedIndex: number | null;
    };
    pushExtraNoLimits: (state: RunState, segment: string, segmentIndex: number) => {
        positionals: {
            value: string;
            extra: boolean | typeof NoLimits;
        }[];
        tokens: Token[];
        candidateUsage: string | null;
        requiredOptions: string[][];
        errorMessage: string | null;
        ignoreOptions: boolean;
        options: {
            name: string;
            value: any;
        }[];
        path: string[];
        remainder: string | null;
        selectedIndex: number | null;
    };
    pushTrue: (state: RunState, _segment: string, segmentIndex: number, name: string) => {
        options: {
            name: string;
            value: any;
        }[];
        tokens: Token[];
        candidateUsage: string | null;
        requiredOptions: string[][];
        errorMessage: string | null;
        ignoreOptions: boolean;
        path: string[];
        positionals: {
            value: string;
            extra: boolean | typeof NoLimits;
        }[];
        remainder: string | null;
        selectedIndex: number | null;
    };
    pushFalse: (state: RunState, _segment: string, segmentIndex: number, name: string) => {
        options: {
            name: string;
            value: any;
        }[];
        tokens: Token[];
        candidateUsage: string | null;
        requiredOptions: string[][];
        errorMessage: string | null;
        ignoreOptions: boolean;
        path: string[];
        positionals: {
            value: string;
            extra: boolean | typeof NoLimits;
        }[];
        remainder: string | null;
        selectedIndex: number | null;
    };
    pushUndefined: (state: RunState, segment: string, segmentIndex: number, _name: string) => {
        options: {
            name: string;
            value: any;
        }[];
        tokens: Token[];
        candidateUsage: string | null;
        requiredOptions: string[][];
        errorMessage: string | null;
        ignoreOptions: boolean;
        path: string[];
        positionals: {
            value: string;
            extra: boolean | typeof NoLimits;
        }[];
        remainder: string | null;
        selectedIndex: number | null;
    };
    pushStringValue: (state: RunState, segment: string, segmentIndex: number) => {
        options: {
            name: string;
            value: any;
        }[];
        tokens: Token[];
        candidateUsage: string | null;
        requiredOptions: string[][];
        errorMessage: string | null;
        ignoreOptions: boolean;
        path: string[];
        positionals: {
            value: string;
            extra: boolean | typeof NoLimits;
        }[];
        remainder: string | null;
        selectedIndex: number | null;
    };
    setStringValue: (state: RunState, segment: string, segmentIndex: number) => {
        options: {
            name: string;
            value: any;
        }[];
        tokens: Token[];
        candidateUsage: string | null;
        requiredOptions: string[][];
        errorMessage: string | null;
        ignoreOptions: boolean;
        path: string[];
        positionals: {
            value: string;
            extra: boolean | typeof NoLimits;
        }[];
        remainder: string | null;
        selectedIndex: number | null;
    };
    inhibateOptions: (state: RunState) => {
        ignoreOptions: boolean;
        candidateUsage: string | null;
        requiredOptions: string[][];
        errorMessage: string | null;
        options: {
            name: string;
            value: any;
        }[];
        path: string[];
        positionals: {
            value: string;
            extra: boolean | typeof NoLimits;
        }[];
        remainder: string | null;
        selectedIndex: number | null;
        tokens: Token[];
    };
    useHelp: (state: RunState, segment: string, _segmentIndex: number, command: number) => {
        options: {
            name: string;
            value: string;
        }[];
        candidateUsage: string | null;
        requiredOptions: string[][];
        errorMessage: string | null;
        ignoreOptions: boolean;
        path: string[];
        positionals: {
            value: string;
            extra: boolean | typeof NoLimits;
        }[];
        remainder: string | null;
        selectedIndex: number | null;
        tokens: Token[];
    };
    setError: (state: RunState, segment: string, _segmentIndex: number, errorMessage: string) => {
        errorMessage: string;
        candidateUsage: string | null;
        requiredOptions: string[][];
        ignoreOptions: boolean;
        options: {
            name: string;
            value: any;
        }[];
        path: string[];
        positionals: {
            value: string;
            extra: boolean | typeof NoLimits;
        }[];
        remainder: string | null;
        selectedIndex: number | null;
        tokens: Token[];
    };
    setOptionArityError: (state: RunState, _segment: string) => {
        errorMessage: string;
        candidateUsage: string | null;
        requiredOptions: string[][];
        ignoreOptions: boolean;
        options: {
            name: string;
            value: any;
        }[];
        path: string[];
        positionals: {
            value: string;
            extra: boolean | typeof NoLimits;
        }[];
        remainder: string | null;
        selectedIndex: number | null;
        tokens: Token[];
    };
};
export declare const NoLimits: unique symbol;
export type ArityDefinition = {
    leading: string[];
    extra: string[] | typeof NoLimits;
    trailing: string[];
    proxy: boolean;
};
export type OptDefinition = {
    preferredName: string;
    nameSet: string[];
    description?: string;
    arity: number;
    hidden: boolean;
    required: boolean;
    allowBinding: boolean;
};
export declare class CommandBuilder<Context> {
    readonly cliIndex: number;
    readonly cliOpts: Readonly<CliOptions>;
    readonly allOptionNames: Map<string, string>;
    readonly arity: ArityDefinition;
    readonly options: OptDefinition[];
    readonly paths: string[][];
    private context?;
    constructor(cliIndex: number, cliOpts: CliOptions);
    addPath(path: string[]): void;
    setArity({ leading, trailing, extra, proxy, }: Partial<ArityDefinition>): void;
    addPositional({ name, required }?: {
        name?: string;
        required?: boolean;
    }): void;
    addRest({ name, required }?: {
        name?: string;
        required?: number;
    }): void;
    addProxy({ required }?: {
        name?: string;
        required?: number;
    }): void;
    addOption({ names: nameSet, description, arity, hidden, required, allowBinding, }: Partial<OptDefinition> & {
        names: string[];
    }): void;
    setContext(context: Context): void;
    usage({ detailed, inlineOptions }?: {
        detailed?: boolean;
        inlineOptions?: boolean;
    }): {
        usage: string;
        options: {
            preferredName: string;
            nameSet: string[];
            definition: string;
            description: string;
            required: boolean;
        }[];
    };
    compile(): {
        machine: StateMachine;
        context: Context;
    };
    private registerOptions;
}
export type CliOptions = {
    binaryName: string;
};
export type CliBuilderCallback<Context> = (command: CommandBuilder<Context>) => CommandBuilder<Context> | void;
export declare class CliBuilder<Context> {
    private readonly opts;
    private readonly builders;
    static build<Context>(cbs: CliBuilderCallback<Context>[], opts?: Partial<CliOptions>): {
        machine: StateMachine;
        contexts: Context[];
        process: (input: string[], { partial }?: {
            partial?: boolean;
        }) => RunState;
    };
    constructor({ binaryName }?: Partial<CliOptions>);
    getBuilderByIndex(n: number): CommandBuilder<Context>;
    commands(cbs: CliBuilderCallback<Context>[]): this;
    command(): CommandBuilder<Context>;
    compile(): {
        machine: StateMachine;
        contexts: Context[];
        process: (input: string[], { partial }?: {
            partial?: boolean;
        }) => RunState;
    };
}
export {};
