import { SpecialToken } from './constants.js';
/**
 * A generic usage error with the name `UsageError`.
 *
 * It should be used over `Error` only when it's the user's fault.
 */
export class UsageError extends Error {
    clipanion = { type: `usage` };
    constructor(message) {
        super(message);
        this.name = `UsageError`;
    }
}
export class UnknownSyntaxError extends Error {
    input;
    candidates;
    clipanion = { type: `none` };
    constructor(input, candidates) {
        super();
        this.input = input;
        this.candidates = candidates;
        this.name = `UnknownSyntaxError`;
        const usages = new Set(candidates.map((candidate) => candidate.usage));
        if (this.candidates.length === 0) {
            this.message = `Command not found, but we're not sure what's the alternative.`;
        }
        else if (this.candidates.every((candidate) => candidate.reason !== null && candidate.reason === candidates[0].reason)) {
            const [{ reason }] = this.candidates;
            this.message = `${reason}\n\n${this.candidates.map(({ usage }) => `$ ${usage}`).join(`\n`)}`;
        }
        else if (usages.size === 1) {
            const [{ usage }] = this.candidates;
            this.message = `Command not found; did you mean:\n\n$ ${usage}\n\n${whileRunning(input)}`;
        }
        else {
            this.message = `Command not found; did you mean one of:\n\n${Array.from(usages, (usage, index) => `${`${index}.`.padStart(4)} ${usage}`).join(`\n`)}\n\n${whileRunning(input)}`;
        }
    }
}
export class AmbiguousSyntaxError extends Error {
    input;
    usages;
    clipanion = { type: `none` };
    constructor(input, usages) {
        super();
        this.input = input;
        this.usages = usages;
        this.name = `AmbiguousSyntaxError`;
        this.message = `Cannot find which to pick amongst the following alternatives:\n\n${this.usages
            .map((usage, index) => {
            return `${`${index}.`.padStart(4)} ${usage}`;
        })
            .join(`\n`)}\n\n${whileRunning(input)}`;
    }
}
const whileRunning = (input) => `While running ${input
    .filter((token) => {
    return token !== SpecialToken.EndOfInput && token !== SpecialToken.EndOfPartialInput;
})
    .map((token) => {
    const json = JSON.stringify(token);
    if (token.match(/\s/) || token.length === 0 || json !== `"${token}"`) {
        return json;
    }
    else {
        return token;
    }
})
    .join(` `)}`;
//# sourceMappingURL=errors.js.map