import type { Token } from './core/index.js';
import type { MiniProgram } from './program.js';
/**
 * The usage of a Command.
 */
export type Usage = {
    /**
     * The category of the command.
     *
     * Included in the detailed usage.
     */
    category?: string;
    /**
     * The short description of the command, formatted as Markdown.
     *
     * Included in the detailed usage.
     */
    description?: string;
    /**
     * The extended details of the command, formatted as Markdown.
     *
     * Included in the detailed usage.
     */
    details?: string;
    /**
     * Examples of the command represented as an Array of tuples.
     *
     * The first element of the tuple represents the description of the example.
     *
     * The second element of the tuple represents the command of the example.
     * If present, the leading `$0` is replaced with `cli.binaryName`.
     */
    examples?: [description: string, command: string][];
};
/**
 * The definition of a Command.
 */
export type Definition = Usage & {
    /**
     * The path of the command, starting with `cli.binaryName`.
     */
    path: string;
    /**
     * The detailed usage of the command.
     */
    usage: string;
    /**
     * The various options registered on the command.
     */
    options: {
        preferredName: string;
        nameSet: string[];
        definition: string;
        description?: string;
        required: boolean;
    }[];
};
export type CommandClass = {
    new (): Command;
    paths?: string[][];
    usage?: Usage;
};
export declare abstract class Command {
    [`constructor`]: CommandClass;
    static paths?: string[][];
    /**
     * Just an helper to use along with the `paths` fields, to make it
     * clearer that a command is the default one.
     *
     * @example
     * class MyCommand extends Command {
     *   static paths = [Command.Default];
     * }
     */
    static Default: never[];
    /**
     * Contains the usage information for the command. If undefined, the
     * command will be hidden from the general listing.
     */
    static usage?: Usage;
    static Usage(usage: Usage): Usage;
    /**
     * Standard function that'll get executed
     *
     * Expected to return an exit code or nothing (which will be treated
     * as if 0 had been returned).
     */
    abstract execute(): Promise<number | void>;
    /**
     * Standard error handler which will simply rethrow the error. Can be used
     * to add custom logic to handle errors from the command or simply return
     * the parent class error handling.
     */
    catch(error: any): Promise<void>;
    /**
     * Predefined that will be set to true if `-h,--help` has been used, in
     * which case `Command#execute` won't be called.
     */
    help: boolean;
    /**
     * Predefined variable that will be populated with the path that got used
     * to access the command currently being executed.
     */
    path: string[];
    /**
     * Predefined variable that will be populated with the tokens found when
     * interpreting the command line.
     */
    tokens: Token[];
    /**
     * Predefined variable that will be populated with a miniature API that can
     * be used to query the program that ran this command.
     */
    program: MiniProgram;
}
